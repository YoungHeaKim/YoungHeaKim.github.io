{"pages":[{"title":"About","text":"Yh Blog","link":"/about/index.html"}],"posts":[{"title":"용해의 개발 블로그","text":"","link":"/hello-world/"},{"title":"HTML 이란?","text":"HTML이란? HTML이란? Hyper Text Markup Language로써 글을 html이라는 확정자를 통해서 Text를 view로 변환하여 사용자가 볼수있게 해주는 언어 SemanticMarkup이란? 웹사이트 콘텐츠를 설명하는데 사용되는 마크업 언어입니다. 비주얼 디자인(모양, 색, 크기 등)이 목표가 아니라, 구조 설계를 목표로 한다. HTML이 필요한 이유 확장자 마다 웹브라우저가 마음대로 해석하는데 이때 웹브라우저가 해석하지 않고 개발자가 웹이 제대로 된 방법으로 해석하기 위해 사용","link":"/HTML/html/"},{"title":"HTML 공부 순서","text":"HTML 공부 순서 HTML이란? HTML 구조","link":"/HTML/index/"},{"title":"HEXO 설치 및 테마 적용법","text":"HEXO 설치 및 테마 적용법 소개 이번 블로그에서는 다음과 같이 Github Page와 HEXO를 사용하여 GitHub Page GitPage는 정적 페이지를 username.github.io로 쉽게 호스팅하도록 도와줍니다 자세한 소개 HEXO 정적 페이지를 쉽게 만들 수 있도록 도와주는 블로그 프레임워크이다. 자세한 소개 장점으로는 npm을 사용해 간단히 설치 가능하다. Node.js 기반으로 매우 빠른 생성 속도를 제공한다. 다양한 플러그인을 지원 Markdown의 모든 기능을 지원하기 때문에 Markdown으로 블로그 작성가능하다. GitHub Page 사용하여 호스팅하기 GitPage는 Github에 가입이 되어있어야 사용이 가능합니다. 그러기 위해서는 Github 회원가입 하기에서 가입을 해주시고 다음으로 넘어가주세요ㅎ Git Repo 생성하기 gitPage를 만들기 위해서는 username.github.io라는 이름을 가진 Repository를 생성 해주어야 하는데 다음 사진에서 Repository name에 다음과 같이 username.github.io라는 Repo를 생성해줍니다. 다음 Public과 Private중 선택해주어야 하는데 public은 해당 Repo를 다른 사람들과 코드를 공유할 수 있게 해주는 부분이고 Private은 다른사람에게 해당 Repo를 공유하지 않는 부분입니다. 그 다음 ReadMe file은 추가를 해주어도 되고 안해주어도 됩니다.(저는 이부분에서 ReadMe 파일을 추가해주지 않고 생성해주었습니다. 추가하지 않으면 원하는 폴더와 git remote해주는 설명이 나옵니다.그렇지만 처음 하시는 분들은 ReadMe파일을 생성하고 만들어 주세요~!!) 정적 페이지 테스트 위에서 생성한 repository가 정적 페이지로 잘 올라갔나 확인 해볼 차례입니다. 자신의 블로그 주소는 https://{userName}.github.io/입니다. {userName}부분에는 자신의 user이름을 넣어주시면 됩니다. 저의 경우는 userName이 youngheakim이므로 https://youngheakim.github.io/이 저의 블로그 주소가 됩니다. Hexo 설치 주의사항 Hexo를 설치할때 Node.js가 설치되어 있어야합니다. Node.js가 설치되어 있지 않다면 Node.js 설치하기로 들어가셔서 노드 LTS버전을 설치하고 진행해 주세요. 1. Hexo 클라이언트 설치 HEXO를 사용하기 위해서 npm에서 Hexo 클라이언트를 설치해야합니다. 터미널이나 CMD를 열고 다음 명령어를 입력해주세요 1npm install hexo-cli -g 2. Hexo 블로그 폴더 생성 위의 클라이언트 설치가 완료되면 다음 코드를 순차적으로 실행하여 주세요 Hexo를 통해 폴더를 생성 (blogName 부분에 원하는 폴더 이름을 입력해주면 됩니다.) 1hexo init blogName 위에서 만든 폴더로 이동합니다. 1cd blogName hexo로 만든 폴더안에서 npm을 설치하여 줍니다. 1npm install 위의 단계를 모두 문제없이 완료하셨다면 블로그는 생성이 되었습니다. 다음의 코드를 사용하여 확인해 보시면 됩니다. 1hexo s 실행이 완료되면 http://localhost:4000/로 접속하여 확인하시면 밑에 페이지가 나오면 성공입니다. 블로그 수정 이제 블로그를 나에게 맞게 수정하는 법을 알아보도록 하겠습니다. 위에서 만든 블로그 폴더를 열어보면 _config.yml이라는 파일이 생성되있는것을 볼 수 있습니다. _config.yml을 열어서 기본 정보를 수정해보겠습니다. 1. site 기본정보 수정12345678# Sitetitle: Hexo # title 이름subtitle: '' # 블로그 sub 타이틀description: '' # 해당 블로그에 대한 설명keywords: # 검색 시에 검색되는 블로그 키워드author: John Doe # 작성자 language: en # 언어 설정timezone: '' # 시간 저의 경우에는 다음과 같이 변경하였습니다. 12345678# Sitetitle: YH's Blogsubtitle: 'YH`s Developer Blog'description: 'YH`s Developer Blog'keywords: programming, Reactauthor: YoungHeaKimlanguage: kotimezone: 'Asia/Seoul' 2. URL 정보 수정 다음과 같은 부분을 찾아서 자신에게 맞게 URL을 변경해주어 github Page와 연결 시켜 줍니다. url부분에 http://example.com 대신 https://{userName}.github.io/를 넣어주면 됩니다. permalink는 md파일을 생성시 url 뒤에 붙는 parameter를 말합니다.123456789# URL## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'url: http://example.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 저의 경우에는 다음과 같이 변경해주었습니다.123456789# URL## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'url: https://youngheakim.github.io/root: /permalink: :title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 3. Deploy 설정 다음은 해당 코드를 업데이트할 부분을 설정하여 gitpage와 연결 시켜 줄 차례입니다. 해당 부분을 다음과 같이 변경해 주세요 저희는 git과 연결해줄 것이기 떄문에 다음과 같이 type은 git으로 변경해 주고 위에서 만들어 주었던 Repo를 연결해줍니다. branch의 경우 저는 master 브랜치에 올릴것이기 떄문에 master라고 작성하여 주었습니다.1234# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: '' 저의 경우에는 다음과 같이 변경해주었습니다.123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/YoungHeaKim/YoungHeaKim.github.io.git branch: master 위의 순서를 차례대로 진행하여 문제없으셨다면 성공입니다. Github에 배포하기 이제 github과 헥소 블로그를 연결시켜 github로 배포를 해 볼 차례입니다. hexo를 이용하여 정적 웹 리소스 생성 및 배포하기 hexo g는 웹 리소스를 생성해주는 코드입니다. hexo d는 github에 배포해주는 코드입니다. 다음과 같이 한번에 줄여서 사용 가능합니다.1hexo g -d 다음과 같은 오류 발생 시1ERROR Deployer not found: git 다음과 같은 코드를 실행하여 에러를 해결해 주세요 1npm install hexo-deployer-git --save hexo블로그 gitpage로 블로그 설정 완료 여기까지 성공하셨다면 https://{userName}.github.io/로 접속하여 hexo페이지가 나온다면 블로그와 gitPage 연동이 완료된 것 입니다.","link":"/Hexo/hexoInit/"},{"title":"JS 공부 순서","text":"JS(JavaScript) 공부 순서 JS의 기초 JS Type &amp; 속성 JS 함수 &amp; 조건문 &amp; 3항 연산자 JS 함수 &amp; 반복문(Loop) JS 값과 영역 &amp; 호이스팅/스코프 체이닝 JS 클로져(Closure) JS 숫자/수학 객체 &amp; 문자 객체 JS 함수 객체 속성과 매서드 JS 생성자 &amp; 프로토타입 객체 지향 프로그래밍 vs 함수형 프로그래밍 Load vs DOMContentLoaded 이벤트 비교 JS DOM API","link":"/JS/index/"},{"title":"Hexo 블로그 테마 연결하기","text":"Hexo 블로그 테마 연결하기 Hexo 테마 Hexo 테마에서 많은 테마들 중 자신이 원하는 테마를 찾은 후 이름 부분을 클릭하면 github repo로 이동하게 되는데 Readme 파일에 있는 부분을 차례대로 따라하면 됩니다. 모든 테마에서 공통적으로 사용되는 부분은 다음과 같습니다.1git clone [테마에 링크 써있는거.git] themes/테마이름 위의 코드를 사용하여 원하는 테마를 clone하여 설치하고 _config.yml에 들어가 theme부분을 해당 테마 이름으로 변경해주어야 합니다. 위의 코드까지 변경 후에 밑에 코드를 사용하여 배포를 해준 후 해당 테마가 반영되었는지 확인해 줍니다.1hexo g -d 작동 오류 시 실행시 오류가 발생할 때 npm i [이름] --save라는 명령어를 사용하여 테마가 원하는 패키지들을 다운 받아 주어야합니다. Icarus 테마 연결 저는 Icarus 테마를 연결을 해 줄 것 입니다. 테마 변경에도 변경 안될 시 다음 코드를 사용하여 초기화 해준 후 다시 배포를 해주시면 됩니다.1hexo clean 위의 코드 실행 후 1hexo g -d","link":"/Hexo/theme/"},{"title":"JS 기초 설명","text":"JavaScript란? &amp; 변수 선언 &amp; 주석/디버깅 1. JavaScript란? 사용자와 상호작용을 하기 위한 언어(움직임을 제어) html에 head요소 안, body의 첫번째, body의 마지막에 script태그를 사용하여 사용한다. 다음과 같이 코드를 실행할때 콘솔창에는 header -&gt; body 맨앞 -&gt; body 맨뒤 순으로 실행이 된다.1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; console.log('header 사용') &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; console.log('body맨앞 사용') &lt;/script&gt; &lt;header&gt;...&lt;/header&gt; &lt;main&gt;..&lt;/main&gt; &lt;footer&gt;..&lt;/footer&gt; &lt;script&gt; console.log('body맨뒤 사용') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2. 변수 선언 변수 선언 방법 var : 변수를 선언, 추가로 동시에 값을 초기화. let : 블록 범위 지역변수를 선언, 추가로 동시에 값을 초기화. const : 읽기 전용 상수를 선언. 변수 작성 방법 snake_case (snake_case와 같이 단어를 이어줄때 공백대신에 _를 사용하여 이어주는 방법, 이것을 주로 사용한다.) camelCase (camelCasee와 같이 단어를 이어줄때 뒤에 단어맨앞을 대문자로 표기해주는 방법) 데이터 유형(Types) 숫자형(Number) 문자형(String) 논리형(Boolean) 값 할당(assignment) 대입, 할당 연산자(operator) = 3. 주석 / 디버깅 javascript는 대소문자를 구별하여 Unicode 문자셋을 사용한다. 한줄 주석은 //를 사용하고 여러줄 주석은 /* ~~~~ */를 사용하여야 한다. 중첩 주석은 오류로 표시해준다. Debug = 문제 해결 (오류표시) 익숙해지기 전까지는 문법검사를 통해 문법을 잘 맞추는걸 익숙해지는것을 우선으로 해야한다.","link":"/JS/jsBase/"},{"title":"JS Closure(클로져)","text":"JS Closure(클로져) 01. 클로저(Closures) 개념 이해 클로저 함수와 함수가 선언된 어휘적 환경의 조합 정의된 함수는 그것이 작성된 환경을 기억한다.1234567891011121314151617181920212223242526272829303132// 클로저 함수 예제function numberGenerator() { // 함수 내에 선언된 지역 변수 var num = 1; // 함수 내에 선언된 지역 함수 function upadetaNumber() { console.log(num++); } // 지역함수 반환 return upadetaNumber;}// numberGenerator 함수에서 반환된 지역 함수 updateNumber 함수를 number 변수에 참조한다.var number = numberGenerator();// number는 함수 참조로 실행할 때마다 결과가 출력된다.for (var i = 0; i &lt; 10; ++i) { number();}// 클로저가 되지않는 함수function numberUp() { var num = 0; return num++;}// 다음과 같이 실행시 1만을 출력한다.for (var i = 0; i &lt; 10; ++i) { numberUp();} 클로저를 사용하지 않고 똑같이 실행하는 방법 단, 이렇게 사용시 var num = 0;를 전역 변수로 만들기 떄문에 유용하지 않음. 1234567891011var num = 0;function numberUp() { return num++;}// 다음과 같이 실행시 클로저와 같이 출력한다.for (var i = 0; i &lt; 10; ++i) { numberUp();} 02. 실행 컨텍스트(Execution Context)와 렉시컬 스코핑(Lexical Scoping) 클로저 이해 해당 함수 내의 변수와 해당 부모 환경에 대한 참조를 의미하는 환경으로 구성되어 있다. 상위 환경에 대한 참조는 내부 함수가 작성된 범위 외부 또는 내부에서 호출되는지 여부에 관계없으 상위 범위의 모든 변수를 모든 내부 함수에 사용할 수 있게 한다. 함수가 사실상 환경에 대한 참조를 가지고 있기 때문에 함수가 이 환경을 기억하는 것처럼 보인다. 모든 실행 컨텍스트에는 어휘환경이 있다. 어위 환경은 식별자 바인딩(즉, 변수 및 관련 값)을 통해 계층적 환경 체인에 중첩 할 수 있다. 각 환경이 접근 할 수 있는 일련의 식별자를 벙위(Scope)라고 한다. 범위를 스코프 체이(Scope Chain)을 통해 계층적 환경 체인에 중첩 할 수 있다. 실행 컨텍스트 ECMAScript 사양에서 코드의 런타임 평가를 추적하는 데 사용되는 추상개념 이다. 코드가 처음 실행되거나 실행 흐름이 함수 전문에 들어갈 때 전역 컨텍스트 일 수 있다.123456789101112131415// 글로벌 실행 컨텍스트var x = 9;// 함수 실행 컨텍스트function outerFn() { var y = 12; // 함수 실행 컨텍스트 function innerFn() { var z = 6; return x+y+z; } return innerFn;} 설명 어느 시점이든 하나의 실행 컨텍스트만 실행 가능 JavaScript가 ‘단일 스레드(멀티태스크 환경에서 OS가 프로그램을 평행 처리 할 때 효율적인 처리를 실현하기 위해 처리를 분할하는데, 그 단위를 스레드라고 한다.)’인 이유이다. 한 번에 하나의 명령만 처리 할 수 있다. 일반적으로 브라우저는 ‘스택(Stack)’을 사용하여 실행 컨텍스트를 유지 관리한다. 스택은 LIFO(Last In First Out) 데이터 구조이다. 현재 또는 실행 중인 실행 컨텍스트는 항상 스택의 맨 위에 있는 항목이다. 실행 중인 실행 컨텍스트의 코드가 완전히 평가되면 최상위 항목이 팝(pop)된 다음 실행 항목이 실행 컨텍스트를 실행하는 것으로 간주된다.123456[ 실행 컨텍스트 N + 4 ] //현재 실행 컨텍스트[ 실행 컨텍스트 N + 3 ][ 실행 컨텍스트 N + 2 ][ 실행 컨텍스트 N + 1 ][ 실행 컨텍스트 N ][ 실행 컨텍스트 ] // 글로벌 다음의 함수들을 봤을때 GlobalEnvironment &gt; fooEnvironment &gt; barEnvironment순의 크기를 가진다.1234567891011121314151617181920212223242526272829303132333435363738// 글로벌 실행 컨텍스트 환경GlobalEnvironment = { // 환경 레코드 EnvironmentRecord: { // 내장(built-in) 식별자(identifiers) Array: '&lt;func&gt;', Object: '&lt;func&gt;', // 기타(etc) // 사용자 정의 식별자 x: 10 } // 외부 참조 outer: null};// foo: 실행 컨텍스트 환경fooEnvironment = { // 환경 레코드EnvironmentRecord: { // 사용자 정의 식별자 y: 20, bat: '&lt;func&gt;', } // 외부 참조 outer: GlobalEnvironment};// bar: 실행 컨텍스트 환경barEnvironment = { // 환경 레코드EnvironmentRecord: { // 사용자 정의 식별자 z: 30, } // 외부 참조 outer: fooEnvironment}; 03. 실용적인 클로저 활용1234567&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;값0&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;값1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;값2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;값3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;값4&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425var nav_links = els('.app-navigation a');var i = 0;var l = nav_links.length;function onNavLink(i, e) { e.preventDefault(); console.log(i, this);}// ES6for (let i=0, l=nav_links.length; i&lt;l; ++i) { nav_links[i].addEventListener('click', function(e) { e.preventDefault(); console.log(i); })}// ES5for (; i&lt;l; ++i) { var link = nav_links[i]; link.addEventListener('click', (function(index) { return onNavLink.bind(link, index); // Function.prototype.bind [.call(), .apply()] })(i));}","link":"/JS/jsClosure/"},{"title":"JS 생성자 &amp; 프로토타입","text":"JS 생성자 &amp; 프로토타입 01. 생성자 함수와 프로토타입 객체 JavaScript 객체(Instance)는 생성자(Constructor)함수를 통해 생성됩니다. new 연산자 뒤에 생성자 함수를 실행하면, 내장 객체 또는 사용자 정의 객체 인스턴스를 생성한다. 사용자 정의 객체에 필요한 수행 단계 함수를 작성하여 객체 타입을 정의한다. 관례적으로 첫글자를 대문자로 작성하여, 일반함수와 구분한다. JavaScript의 모든 함수 객체는 정의 동시에 자동으로 함수의 프로토타입(Prototype) 객체를 참조하는 속성 .prototype을 가지게 된다. Tab.prototype속성에 참조된 객체는 .constructor속성을 가지며, 이 속성을 통해 생성자 함수 Tab을 참조한다. new 연산자로 객체의 인스턴스를 생성한다. 정의된 생성자 함수를 new 연산자와 함께 실행하면 객체 인스턴스를 생성한다. 02. 생성자 함수와 instance 함수 생성자 함수가 실행 될 때 Tab.prototype을 상속(Inheritance)하는 새로운 객체가 하나 생성 새롭게 생성된 객체에 바인드 된 this와 함께 생성자 함수 Tab가 호출된다. new Tab은 new Tab()과 동일하다. 즉 전달인자가 없을 경우, 인자 없이 Tab이 호출된다. 생성자 함수의 실행 결과, 생성된 객체는 함수의 결과물로 반환된다.(return 기본 값) 만약 명시적으로 사용자가 다른 객체를 반환할 경우, 반환 결과물을 덮어쓸 수 있다. 밑의 코드에서 instance, instance1, instance2는 모두 동일한 프로토타입 객체를 상속한다. Tab 생성자 함수는 객체를 생성하는 모체 역할을 수행한다. Tab.prototype 객체는 Tab 생성자를 통해 생성된 모든 객체가 공통으로 상속하는 속성/매서드 집합이다. Tab 생성자는 전달 인자를 통해 객체 고유의 속성을 설정할 수 있다.12345678910111213141516function Tab(selector) { // 여기서의 this는 instance 객체를 가르킨다. this.el = document.querySelector(selector);}// 아래 두 코드는 동일한 동작을 수행var instance1 = new Tab;var instance2 = new Tab();// 함수내에 전달인자를 전달해 a 객체가 생성되는 과정에서 사용// a함수는 생성자 함수 이고 instance는 instance 객체이다. var instance = new Tab('body');console.log(instance);// 다음과 같이 작성하게 되면 Tab함수를 가르킨다.console.log(instance.constructor.prototype);console.log(Object.getPrototypeOf(instance)); // 이 방법을 더 권장 03. @constructor와 @prototype와 @instance @constructor Pagenation 생성자 함수를 정의 el, options 전달인를 받을 수 있다. 전달된 인자는 생성된 객체(this)의 el, options 속성에 할당한다. @prototype Pagenation.prototype 객체에 추가된 속성(메서드)는 Pagenation 생성자를 통해 생성된 모든 객체의 공통 속성(메서드)이다. @instance 생성자를 통해 생성된 객체 인스턴스는 생성 과정에서 전달된 개별 인자를 통해 고유 속성 값을 가지게 된다. 04. 알반 함수 vs 생성자 함수 Strict 모드 생성자 함수와 일반 함수를 구분할 수 없어 new 연산자 사용 없이 생성자 함수를 사용한다면 오류도 발생하지 않고, 작동도 안되고 전역도 오염시키게 된다.12345678910// JavaScript에서는 a가 정의되지 않아도 전역변수로 a를 생성한 후 오류발생을 시키지 않는다.(function() { a = 'a';})();// 'use strict'를 사용해 주면 strict mode를 사용하여 이러한 문제를 봉쇄하여 오류를 발생 시켜준다.(function() { 'use strict' b = 'a';})();","link":"/JS/jsCreater/"},{"title":"JS Dom","text":"JS DOM 1. DOM API - 문서 객체(들)에 접근하는 방법 id 속성 값으로 선택하는 방법 document.getElementById('id이름')과 같이 사용 class 속성 값으로 선택하는 방법 document.getElementsByClassName('class이름')과 같이 사용 TagName으로 값을 선택하는 방법 document.getElementsByTagName(tagName이름) CSS 선택자로 선택하는 방법 document.querySelector('#id이름')과 같이 사용 (단수만 가져옴) document.querySelectorAll('.id이름')과 같이 사용 (복수 리스트르 가져옴) 2. DOM API - 이벤트 핸들링(Event Handling) 사용자가 이벤트를 발생시 함수를 실행시켜주는 핸들링이다. 이벤트 속성 on(EventType) click mouseover dragstart … 함수 이벤트 속성에 연결된 함수 : 이벤트 객체를 매개변수로 전달 받는다. 사용법 js에서 원하는 tag를 가져온 후 사용하는 방법 HTML에서 원하는 곳에 직접 넣어 사용해주는 방법 3. DOM API - 마우스 이벤트 핸들링 &lt;a href&gt; 요소의 기본 동작 차단이 필요한 이유 click 이벤트는 마우스 이벤트지만, 접근성도 준수 가능한 이벤트입니다. 4. DOM API - 키보드 이벤트 핸들링 이벤트 속성 keydown keypress keyup input(HTML5) 이벤트 객체(Event Object) 이벤트 발생 순서 keydown -&gt; keypress -&gt; keyup 키다운하는 두가지 방법 window.onkeydown = function(){}: 구형 window.addEventListener('keydown', function(){}): 신형 키보드 숫자 찾는법 console.log(e.type, ' = ', e.keyCode, ' | ', e.code, ' | ', e.key)를 사용해서 원하는 키의 번호를 찾는다. event를 주면 해당 요소에 클래스 리스트에 event이름이 추가 되있는데 이때 다시 동작 하려면 해당 요소에서 event이름을 지워주어야 한다. 원하는요소선택.addEventListener('animationend', stand)를 사용하여 애니메이션을 끝내주고 function stand(){원하는요소선택.classList.remove('지우고 싶은 className')} 5. DOM API - 문서 프로그래밍 인터페이스 HTML은 웹 페이지의 내용과 양식을 저장하기 위해 사용된다. CSS는 웹 페이지가 시각적으로 어떻게 보일지 결정한다. JavaScript는 웹 어플리케이션에 더 풍부한 효과를 주기 위해 사용된다. 웹브라우저에서 자바스크립트는 여러가지 다른 뜻을 가진 포괄적인 용어로, 한가지 뜻은 핵심언어(ECMA 스크립트)이고 나머지 뜻은 DOM(Document Object Model)이다. ECMAScript 언어 문법(파싱 규칙, 키워드, 흐름 제어, 오브젝트 리터럴 초기화 등) 에러 처리 방법 (throw, try/catch, 유저가 직접 정의한 에러 등) 타입들(Boolean, number, string, function, object, array …) 전역 오브젝트, 브라우저 환경에서는 window 오브젝트가 전역 오브젝트, 몇가지의 함수들이 이 오브젝트에 포함 됨(parseInt, parseFloat … 등) 프로토타입을 기반으로한 상속 구조 내장 객체 및 함수들(JSON, Math, Array, Object, … 등) DOM DOM의 표준은 W3C에 의해 관리된다. HTML, XML 문서를 오브젝트로 추상화하여 언어에 관계없이 이들을 다루는 방법이 정의되어 있다. DOM에서 정의된 것들 중에 다음과 같은 것들이 중요하다. 문서 구조, 트리모델(tree model), DOM core에 있는 이벤트 구조, Node, Element, Document, Event, EventTarget, … 등 덜 엄격한 DOM 이벤트 구조, DOM events에 속하는 특정 이벤트 DOM 탐색, DOM 영역 등 5-1. DOM API - 선택 / 매칭 메서드 DOM 선택 API 메서드 getElementById() getElementsByTagName() getElementsByClassName() (IE 9+) querySelector() (IE 8+ CSS2 선택자로 제한, IE 9+) 주요 사용 querySelectorAll() 주요 사용 matches() 주요 사용 msMatcheselector() (IE 9+ 프리픽스) 5-2. DOM API - Node 속성 Node 속성 firstChild : 첫번째 자식의 요소를 가져온다 lastChild : 마지막 자식의 요소를 가져온다 nextSibling : 요소에 인접한 Node를 가져온다. previousSibling : 요소에 인접한 Node를 가져온다. nextElementSibling : 요소에 인접한 요소를 가져온다. previousElementSibling : 요소에 인접한 요소를 가져온다. 6. DOM API Part 2 - 문서 프로그래밍 인터페이스6-1. 데이터 순환 후, HTML 구조 동적 생성 / 문서 추가 DOM을 사용해서 페이지 제작 js파일을 생성후 js파일 내에서 HTML구조를 생성 후 대입해줄 수 있다. 6-2. 페이지를 스크롤 하여 하단에 도착하게 되면, 메뉴 목록을 통째로 복사해서 문서에 추가 Node.replaceChild() 특정 부모 노드의 자식 노드를 다른 노드로 교체해준다. replaceNode = parentNode.replaceChild(newChild, oldChild); Node.cloneNode() Node의 복제된 Node를 반환한다. var dupNode = node.cloneNode(deep); : deep에는 true, false를 넣어준다. Event는 복제 되지않는다. Node.isEqualNode(OtherNode) Node가 비교한 Node와 같은지 비교하는 method이다. 6-3. 제거 버튼 동적 생성 후, 메뉴 아이템에 추가 / 클릭 이벤트 발생 시, 메뉴 아이템 제거 parent.parentNode.removeChild(parent) 원하는 요소를 삭제 시켜준다. 7. DOM API - ElementNode 속성 / 메서드7-1. HTML 요소 속성, 메서드 ParentNode.children readOnly 속성이기 떄문에 변경이 되지 않는다. firstElementChild lastElementChild nextElementsChild innerHTML outerHTML innerText 7-2. 보다 강력한 HTML 코드, 요소, 텍스트 삽입 HTML Element 메서드 getAttribute() setAttribute() removeAttribute() hasAttribute() (요소 노드에 속성이 있으면 값이 없어도 true를 반환, Boolean 속성 반환 값일 경우 상태 확인 가능) Element.insertAdjacentHTML() 메서드는 HTML or XML 같은 특정 텍스트를 파싱하고, 특정 위치에 DOM tree 안에 원하는 node들을 추가 한다. 이미 사용중인 element 는 다시 파싱하지 않는다. 그러므로 element 안에 존재하는 element를 건드리지 않는다. (innerHtml은 과 좀 다름). innerHtml보다 작업이 덜 드므로 빠르다.1element.insertAdjacentHTML(position, HTML); 이때 position에 들어갈 값 4가지1234567&lt;!--beforebegin--&gt;&lt;p&gt;&lt;!--afterbegin--&gt; foo&lt;!--beforeend--&gt;&lt;/p&gt;&lt;!--afterend--&gt; 이때, element.appendChild(node) 대신에 element.insertAdjacentHTML()를 사용해 주면 좀더 빠른 처리가 가능하다. element.insertAdjacentElement()를 사용해 주면 element값을 넣어줄 수 있다. 1element.insertAdjacentElement(position, element); element.insertAdjacentText()를 사용해주면 text를 원하는 곳 값을 넣어줄 수 있다. 1element.insertAdjacentText(position, Text); 특징 및 주의할 점 innerHTML은 HTML 텍스트 코드를 실제 DOM 노드로 변환한다. textContext는 HTML 텍스트 코드를 단순히 텍스트로 출력한다. document.write() 구문은 로딩 시 HTML 문서 해석을 지연/차단시키니 사용하지 않는 것이 좋다. innerHTML은 무겁고 비싼 대가를 치는 HTML 해석기를 호출하므로 사용에 주의가 요구된다. insertAdjecentHTML()은 beforebegin, afterend 옵션은 노드가 문서 트리에 존재하고 부모 요소 노드를 가진 경우에만 동작한다. textContent는 모든 요소의 내용을 가져올 수 있다. 반면 innerText는 그렇지 않다. innertext는 textContent와 달리 숨겨진 요소들의 텍스트는 반환하지 않는다. insertBefore()사용 시, 두번째 인자를 전달하지 않으면 appendChild() 처럼 동작한다. cloneNode() 사용 시, 모든 속성/값(인라인 이벤트 포함)을 복제한다. 하지만 외부 스크립트에 연결된 이벤트는 복제하지 않는다. cloneNode() 사용 시, id 속성을 사용할 경우 문서 내 id속성 값이 중복되니 주의가 요구된다. 8. DOM API - HTML 요소 스타일 속성 / 메서드8-1. 요소 객체의 style 속성 (element.style)[https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/style] 다음과 같은 메서드 사용시 요소의 style 속성을 나타내는 개체를 반환한다. element.style.marginTop = '10px' 다음과 같이 style뒤에는 cammel case를 사용해 주어야하고 값은 string값이어야 한다. style에 대한 부분을 지울 때는 element.removeAttribute('style')를 사용하여 적용된 style 부분을 지워 준다. element.style.cssText를 사용하여 여러가지 스타일을 한번에 적용 가능하다. 8-2. 메서드와 헬퍼 함수 활용-요소의 모든 CSS 프로퍼티값을 얻기 위해서는 window.getComputedStyle을 사용하여야 한다.-window.getComputedStyle 인자로 전달받은 요소의 모든 CSS 속성값을 담은 객체를 회신한다. 이 속성값들은, 해당 요소에 대하여 활성 스타일시트와 속성값에 대한 기본 연산이 모두 반영된 결과값이다. 개별 CSS속성 값은 객체를 통해 제공되는 API 또는 CSS 속성 이름을 사용해서 간단히 색인화해서 액세스할 수 있다.1var style = window.getComputedStyle(element[, pseudoElt]); 이때 pseudoElt는 일치시킬 의사요소를 지정하는 문자열로 보통의 요소들에 대해서는 생략되거나 null이어야한다. 다음과 같이 사용시에는 height에 관한 css값을 빼올수 있게 된다.1var heightCss = window.getComputedStyle(element, null).getPropertyValue('height'); 주의상항 getComputedStyle은 읽기 전용이기 떄문에 style 설정할 때는 element.style을 사용해주어야한다. 9. DOM API - CSS 객체 모델(CSSOM) CSSOM (CSS Object Model) CSSOM View Module 사양의 대부분 속성은 라이브 상태로 접근 시마다 매번 계산 되며, 읽기 전용 속성이다. (scrollLeft, scrollTop 제외) DOM의 일부인 CSSOM은 CSS와 관련된 다양한 정보를 조작 할 수있는 특정 인터페이스를 제공한다. 요소노드 측정(Geometry) offsetLeft, offsetTop, offsetParent 속성은 HTMLElement 객체의 확장 getBoundingClientRect() 메서드를 사용하면 뷰포트(Viewport) 왼쪽 상단을 기준으로 요소노드의 외부 테두리 위치를 알려준다. 크기 offsetWidth, offsetHeight는 스크롤바를 포함하는 border-box까지의 크기를 나타낸다. clientWidth, clientHeight는 스크롤바를 제외한 padding-box를 나타낸다. scrollWidth, scrollHeight는 box가 가지고있는 scroll이 가능한 사이즈를 말한다.","link":"/JS/jsDOM/"},{"title":"JS 함수 &amp; 조건문 &amp; 3항 연산자","text":"JS 함수 &amp; 조건문 &amp; 3항 연산자 1. JS Function 1-1. 미리 정의된(내장) 함수 window 전역 객체는 생략 가능 window.parseInt() = parseInt() window.parseFloat() = parseFloat() window.alert() = alert() : 경고창 출력 window.confirm() = confirm() : 확인창을 출력해주는 명령어 window.prompt() = prompt() : 확인하고 입력을 받아 사용 console 객체는 생략 불가능 conosle.log() : console 창에 로그를 띄워주는 부분 conosle.info() : console 창에 정보를 띄워주는 부분 conosle.warn() : console 창에 경고를 띄워주는 부분 conosle.error() : console 창에 에러를 띄워주는 부분 1-2. 사용자 정의 함수 - 선언문 명령문12345function 함수이름() { // code block // 할 일 목록 // 절차} 1-3. 함수 표현식과 실행. 그리고 매개변수, 전달인자, 수행 결과 반환 함수 표현식12345var 함수이름 = function() { // code block // 할 일 목록 // 절차} 함수 호출시 함수표현식이나 명령문을 사용할시에 함수이름()와 같이 써주면 실행이 되게됩니다. 함수 전달인자(arguments)와 매개변수(parameters) &amp; 함수 결과 반환12345678// 이때 n1과 n2는 전달이낮이다.function 함수이름(n1, n2) { // code block // 할 일 목록 // 절차 // 함수 결과 반환 return n1 + n2;} 1-4. 쓸모 있는 재사용 가능한 함수 만들기 다음과 같이 자주 사용하는 부분들은 함수로 정의해서 사용해주는 것이 좋다.1234567891011121314151617181920function $(selector){ return document.querySelectorAll(selector);}function $$(selector, context){ if(!context) { context = document; } return document.querySelector(selector);}var all_elms = $('*');var figures = $('figure');var clouds = $('.cloud');var boy= $$('#boy');var info = $$('.info');var kbd = $$('kbd', info);var kbds = $('kbd'); 2. 조건 처리(Condition Processing) if... else...조건문과 switch...문이 있다. 특정 조건이 참(true)인 경우 실행하는 명령의 집합 if... else...조건문 특정 조건이 참인 경우 문장을 실행하기 위해 if문을 사용한다. 또한 선택적으로 조건이 거짓인 경우 문장을 실행하기 위해서는 else를 사용해준다. 거짓으로 판단되는 값 false undefined null 0 NaN ‘’ 3. 비교 연산자와 논리 연산자를 활용한 조건 처리 비교 연산자 == : 값만 비교 === : 값과 type까지 비교 (권장) != : 값만 비교(같지 않을 때 참) !== : 값과 type까지 비교 (권장) &gt; : 크기 비교 &gt;= : 크기 비교 &lt; : 크기 비교 &lt;= : 크기 비교 논리 연산자 AND =&gt; &amp;&amp; : 두개다 참일떄만 참 OR =&gt; || : 한개라도 참이면 참 NOT =&gt; ! 4. 조건문 → switch 문. 그리고 날짜(Date) 객체4-1. switch문 사용법 switch문은 표현식을 평가하고 값을 조건과 비교한다. 만약 값이 일치한다면, 프로그램은 각 조건의 하위 문장을 실행한다. 조건문이 많을때 if문보다 더 빠르게 사용에 유용하다.123456789101112131415161718switch ('비교할 값') { case &quot;비교한 값&quot;: console.log('비교한 값이 참일때') break; case &quot;비교한 값&quot;: console.log('비교한 값이 참일때') break; case &quot;비교한 값&quot;: console.log('비교한 값이 참일때') break; case &quot;비교한 값&quot;: console.log('비교한 값이 참일때') break; case &quot;비교한 값&quot;: console.log('비교한 값이 참일때') break; default: console.log('비교한 값이 모두 거짓일때');} 4-2. Date 객체 사용법 new Date()를 사용하여 현재 연도, 날짜, 시간 등을 가져올 수 있다. .getFullYear() : 현재 연도를 가져옴 .getMonth() + 1 : 현재 달를 가져옴 .getDate() : 현재 날짜를 가져옴 .getDay() : 현재 일을 가져옴 .getHours() : 현재 시를 가져옴 .getMinutes() : 현재 분을 가져옴 .getMilliseconds() : 현재 초를 가져옴 .getTime() : 현재 시간을 가져옴 .getISO_time() : ISO 시간 기준으로 현재 시간을 가져옴 5. 3항 연산 식5-1. 3항 연산식이란? 조건 ? 값1 : 값2; 과 같은 연산자를 사용 조건이 참인 경우 값1을 출력하고 거짓일 때는 값2를 출력한다. 5-2. 논리곱(&amp;&amp;)과 논리합(||) 연산자 논리곱(&amp;&amp;)과 논리합(||) 연산자 앞의 조건이 참이면 &amp;&amp;의 뒤에 문이 실행 앞의 조건이 거짓이면 ||의 뒤에 문이 실행","link":"/JS/jsFunction/"},{"title":"JS Array &amp; 조건 반복문","text":"배열(Array)과 반복 문(Loop) 01. 배열과 반복/순환 문 배열의 구조 const array = [0,'문자']와 같이 []를 사용하고 안에 값으로 number와 string이 들어갈수 있다. 반복&amp; 순환문이 필요한 이유 반복 처리가 필요한 일을 사람 대신 프로그래밍이 처리해 줌으로 불필요한 공정을 줄여준다. 배열 객체 생성 방법 두가지 let array = ['',''] : 리터럴 방식 사용 권장 let array = new Array() 배열 속성 .push() .length 1234567const array = [0,'문자'];array.push('추가'); // 배열에 값을 추가array.pop(); // 배열에 값을 빼주기let length = array.length; // 배열의 길이를 알려주는 코드rst = array[0]; // 첫번쨰 요소를 가져오는 법let first = array[0]; // 첫번째 요소를 가져오는 법let last = array[array.length -1]; // 마지막 요소를 가져오는 법 02. while 문 조건 값이 참이면, 코드 블럭 실행 조건 값이 참이면, 참일 동안 계속 반복 실행 조건을 거짓으로 변경하는 중단점이 필요.(사용자가 실행) -&gt; 무한루프 실행될 수 있음12345678910const while_condition = true;const count = 0;// while(반복문을 돌리고 싶은 숫자)while(while_condition) { count = count +1; console.log(count); if(count &gt; 10) { while_condition = false; }} if문과 while문 차이 if문 조건이 참이면 1회 실행 while문 조건이 참이면 반복 실행 03. continue, break, label 문 &amp; do ~while 문 continue 문 반복 중 조건이 충족할 경우, 조건 확인 영역으로 이동 break 문 반복(순환) 중 조건이 충족할 경우, 실행 종료(반복문 종)료 label 문 참조 가능한 식별자료 continue, break에 의해 식별 while문이 중첩되었을 때 사용123456789101112131415161718192021const while_condition = true;const count = 0;const innerCount = 0;const repeatingCount = 10;loopCount: while(while_condition) { ++count; if(count === 3 || count === 7) { continue } // continue 문 사용 while(true) { innerCount++; if(innerCount === repeatingCount/2) { break loopCount; } // continue 문 사용 console.log(' - innerCount:', innerCount); } if(count === 6) { break } // break 문 사용 if(count &gt;= repeatingCount) { while_condition = false; }} do ~while문과 while문 차이 while문 : 조건이 false면 실행이 되지 않는다. do~while문 : 조건이 false라도 한번은 실행이 된다.123do { console.log('조건이 거짓')} while (false) 04. for 문 조건이 거짓으로 판별될 때까지 반복 for([초기문]; [조건문]; [증강문]) { ... }","link":"/JS/jsLoop/"},{"title":"JS Load vs DOMContentLoaded 이벤트 비교","text":"Load vs DOMContentLoaded 이벤트 비교 01. 스크립트 의존성(Dependecy) / 브라우저의 HTML, CSS, JavaScript 해석 흐름 / Load 이벤트 스크립트 의존성 JavaScript파일을 불러올 때의 순서에 따라서 불러온 파일에 의해 의존하여 함수를 만들었을 경우 의존하는 파일을 위에서 불러주어야 한다. HTML의 header부분 읽음 -&gt; HTML 읽기 멈춤(Script 서버에서 다운로드 -&gt; Script 실행) -&gt; HTML의 body부분 읽음 만약 Script가 멈추면 다시 서버에서 다운 및 실행이 모두 완료된 후 HTML body부분을 읽는다. Load 이벤트 모든 이벤트가 해석된 이후에 init이라는 함수를 실행해달라고 하고는 이벤트이다. 이부분에서 init은 초기화함수이다.12// 이미지까지 모두 로드한 후 실행window.addEventListener('load', init) // 1.24초 02. DOMContentLoaded 이벤트 / 스크립트 삽입 위치에 따른 HTML 파싱(Parsing) 지연 여부 위에서 Load 이벤트를 실행하여도 html파일을 읽는 것을 멈추는 시간은 변하지 않고 단지 순서만 HTML body부분을 읽은 후 실행해주는 것이여서 시간을 단축하지는 않는다. 위의 단점을 보완하기 위해 DOMContentLoaded를 사용하여 준다. Html이나 css나 script는 img를 다운받기 전에 이미 다운을 받았는데 img의 용량과 파일의 종류에 따라 다운로드 시간이 오래 걸리기 떄문에 Load시간과 DOMContentLoaded의 시간의 차이가 발생한다. 이때 DOMContentLoaded를 사용하여 img다운을 받기전에 script를 실행시켜준다. 이렇게 되면 빠르게 화면이 작동 된다.12// 문서객체구조가 완성되면 실행window.addEventListener('DOMContentLoaded', init) // 0.2초 이때 이벤트를 사용하지 않는 방법 HTML head에 script파일을 작성하지 않고 body 마지막 부분에 script를 작성해주면 된다. 03. async 속성과 defer 속성 차이 defer 속성 script의 defer는 HTML이 읽는 것에 대해 방해하지 않는다. 다운로드는 똑같이 받는데 다운로드 받으면서 동시에 HTML파일을 읽고 다 읽은 후에 script를 실행시켜준다. async 속성 비동기 방식이다. 실행할 때만 멈춘다. 오류가 있는 부분이 있어서 권장하지는 않는다. 04. 동기 vs 비동기 동기 일을 하나씩 처리하는 방식을 말한다. 비동기 일을 하나 처리하면서 동시에 다른일을 처리해주는 방식을 말한다.(지연시간이 없다.)","link":"/JS/jsLoad/"},{"title":"JS 숫자&#x2F;수학 객체 &amp; 문자 객체","text":"JS 숫자/수학 객체 &amp; 문자 객체 1. 숫자 / 수학 객체1-1. JavaScript 수는 부동소수점 사용 Math 객체 Math.min() : 최솟값 Math.max() : 최댓값 Math.random() : 난수 Math.floor() : 내림 Math.round() : 반올림 Math.ceil() : 올림 Math.abs() : 절대값 Math.pow() : 제곱 Math.sqrt() : 제곱근 Math.trunc() : 정수 반환(소수점 제거) 1-2. JavaScript 수학 객체 JavaScript는 모든 숫자는 부동 소수점이다. 3개의 상징적인 값 +Infinity -Infinity NaN 숫자 값(리터럴)의 4가지 유형 10진수 : 0으로 시작 가능, 만약 0다음에 나오는 모든 수가 8보다 작으면 8진수로 해석 2진수 : 0 다음 b 또는 B 사용, 0b이후 숫자가 (0,1,2,3,4,5,6,7)를 벗어나면 10진수로 해석 8진수 : 앞에 0 사용, 0이후 숫자가 (0,1,2,3,4,5,6,7)를 벗어나면 10진수로 해석 16진수 : 0 다음 x 또는 X 사용, 0x이후 숫자가 (0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f)를 벗어나면 오류 부동 소수점 연산은 항상 결과가 100% 적확하지는 않는다. 해결책1 : 소수점을 정수로 변환하여 계산해주고 다시 소수점으로 변경한다. 해결책2 : Number((0.1 + 0.2).toPrecision(12))을 사용해 준다. Number 속성 Number.MAX_VALUE : 1.7976931348623157e+308 Number.MIN_VALUE : 5e-324 Number.NaN : NaN Number.POSITIVE_INFINITY : +Infinity Number.NAGATIVE_INFINITY : -Infinity Number.EPSILON : 2.220446049250313e-16 Number.MIN_SAFE_INTEGER : -9007199254740991 Number.MAX_SAFE_INTEGER : 9007199254740991 Number 스태틱 메서드 Number.parseFloat() Number.parseInt() Number.isFinite() Number.isInteger() Number.isNaN() Number.isSafeInteger() Number 인스턴스 메서드 .toExponential() - 지수 표기법 안에서 번호를 나타내는 문자열을 반환 .toFixed() - 문자열 고정 소수 점 표기법의 수를 나타내는 문자열을 반환 .toOrecision() - 지정된 정밀에 고정 소수 점 표기법의 수를 나타내는 문자열을 반환 2. 문자 객체 String 객체 ''(홀따움표)이나 &quot;&quot;(쌍따움표) 안에 들어가 있는 문자는 문자열로 표시한다. 텍스트 형태로 표현될 수 있는 데이터를 보관하는데 유용","link":"/JS/jsMath/"},{"title":"JS 함수 객체 속성과 메서드 &amp; 배열 객체 &amp; 객체 상속","text":"JavaScript 함수 객체 속성과 메서드 &amp; 배열 객체 &amp; 객체 상속 1. JavaScript 함수 객체 속성과 메서드1-1. 함수 용어정리 함수 정의(선언/표현식, function, var) 함수 실행(호출, ()) 함수 결과 변환 or 종료(return) 함수 재귀(Recursion) : 반복문 함수 스택(Stack) LIFO(Last In First Out) DevTools -&gt; Sources -&gt; Call Stack(with Breakpoint) 확인 중첩 함수(Closure) 다중 중첩 함수(Scope Chaining) 함수 실행 주체 참조(this) 함수는 객체의 소유, 객체는 소유한 함수의 주인(this), 메서드 전달인자 객체(arguments, 유사배열(Array-like Object)) 12. 함수 가이드 이름이 없는 함수(표현식)1var nextEl = function(el) {}; 이름이 있는 함수(선언)1function prevEl(el) {}; 중첩하는(바깥) 함수, 중첩된(안쪽) 함수(클로저)123function outer(count) { return function inner() {};}; 재귀(Recursion)호출 함수1function prevEl() {}; 즉시 실행 함수 표현식(ITFE) ITFE에 인자 전달 -&gt; 내부 매개변수 참조 스코프 체이닝에 따른 성능 문제 해결 1(function() {})(); 1-3. 함수 객체의 속성과 메서드 함수 속성 function.name function.length function.caller(사용 권장하지 않음, 함수 이름으로 재귀해야) 함수 매서드 call() apply() bind() 2. 배열 객체 배열 객체의 속성과 메서드 JavaScript 배열 객체는 모든 것을 수집(Collection) 할 수 있습니다. 배열 객체 생성 방법 [] new Array() 인덱스로 배열 아이템에 접근 array[index] 배열 객체 속성 array.forEach(function(item, index){}) : 배열 객체 아이템들을 순환 처리 array.push(item) : 배열 객체 새로운 아이템 추가(Last In) array.unShift(item) : 배열 객체 새로운 아이템 추가(First In) array.pop() : 배열 객체의 마지막 아이템 제거 array.shift() : 배열 객체 첫번쨰 아이템 제거 array.splice(index, 1) : 배열 객체 아이템 1개 제거 array.splice(index, n) : 배열 객체 아이템 n개 제거 array.length = 0 : 배열 객체 모두 제거 array.length : 배열 객체 길이 array.slice() : 배열 복사 array.isArray() : 배열 검증 (true, false) array.sort() : 배열 순서 정렬 array.reverse() : 배열 순서 뒤집기 배열 객체 변경 매서드 array.push() array.pop() array.unShift() array.shift() array.reverse() array.sort() array.splice() 배열 객체 접근 매서드 array.concat() array.indexOf() array.lastIndexOf() array.join() array.slice() array.toString() 배열 객체 반복 매서드(원본 배열 데이터 보존) array.forEach(function(item, index){}) array.map(function(item, index){}) array.filter(function(item, index){}) array.every(function(item, index){}) array.some(function(item, index){}) array.reduce(function(item, index){}) 3. 객체 상속3-1. 객체 의미와 생성 방법 JavaScript의 모든 객체들은 Object의 자손이다. 객체 생성 방법 {} new Object() 3-2. 객체 속성 정의 객체 속성 정의 Object.create() : 객체 및 속성(property)을 갖는 새 객체를 만듭니다. Object.defineProperty(obj, property, descripter) : 객체에 직접 새로운 속성을 정의하거나 이미 존재하는 객체를 수정한 뒤 그 객체를 반환 객체 확장 차단 새로운 속성을 추가하지 못함. (지우는 것은 가능) Object.preventExtensions() Object.isExtensible() 객체 밀봉(시얼링, Sealing) 객체를 밀봉하면 새로운 속성을 추가할 수 없고, 모든 속성을 설정 불가능 상태로 만들어 줍니다. 하지만 쓰기 가능한 속성의 값은 밀봉 후에도 변경할 수 있습니다. Object.seal() Object.isSealed() 객체 동결 객체의 속성을 지우거나, 바꿀 수 없습니다. 밀봉 + 속성 값 변경 차단 Object.freeze() Object.isFrozen() 객체의 인스턴스 매서드(Instance Methods) .hasOwnProperty() : 자신의 속성을 확인 해주는 함수","link":"/JS/jsMethod/"},{"title":"객체 지향 프로그래밍 VS 함수형 프로그래밍","text":"객체 지향 프로그래밍 VS 함수형 프로그래밍 1. 객체 지향 프로그래밍(OOP, Object Oriented Programming) 생성자 함수와 프로토타입 객체를 사용해 클라스(class)를 어떻게 설계해야하는지에 대해 알아야한다. 생성자 함수와 상속, 프로토 타입 객체 코드가 흩어진 느낌이 든다면? 즉시 실행 함수식(IIFE) 패턴을 사용하면 좀더 묶어서 볼수있게 된다. IIFE 패턴을 사용해 생성자 함수와 상속, 프로토타입 객체를 한데 묶어 관리하면 충돌 걱정도 없고 단 하나의 클래스에만 집중해서 개발이 가능하다. 객체를 지향하여 프로그래밍 하는 방법 모든것을 생성된 객체를 중심으로 생각한다는 것이 함수형 프로그래밍과의 차이를 갖는다. 대표적으로는 JQuery 라이브러리가 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283(function(global, document) { 'use strict' // @constructor function Dom(selector, context) { try { if (typeof selector === 'string') { var _els = (document || selector).querySelectorAll(selector); var i = 0, l = _els.length; for(; i&lt;l; i++) { this[i] = _els[i]; } this.length = l; } else if (selector &amp;&amp; selector.nodeType === 1) { this[0] = selector; this.length = 1; } else { this.length = 0; } } catch (e) { console.log(e.message); } } // @static__methods Dom.each = function(list, callback) { var count = list.length; for (var i = 0; i&lt;count; i++) { callback(list[i], i); } }; // @prototype // @instance__methods // this = Dom.prototype (function() { this.version = '0.0.1'; this.each = function(callback) { Dom.each(this, callback); }; this.on = function(type, handler) { Dom.each(this, function(item, i) { item.addEventListener(type, handler.bind(item, item, i)); }) }; this.hasClass = function(name) { return this[0].classList.contains(name); }; this.addClass = function(name) { var names = name.split(' '); Dom.each(this, function(item, i) { Dom.each(names, function(item, i) { item.classList.add(name); }); }); return this; }; this.removeClass = function(name) { Dom.each(this, function(item, i) { name ? item.classList.remove(name) : item.className = ''; }); return this; }; this.toggleClass = function(name) { Dom.each(this, function(item, i) { if(item.classList.contains(name)){ item.classList.remove(name); } else { item.classList.add(name); } }); return this; }; this.eq = function(index) { return new Dom(this[index]); }; }).call(Dom.prototype); // 공개 Object.defineProperty(global, 'Dom', { value: function(selector, context) { return new Dom(selector, context); } }); Object.freeze(global.Dom);})(window, document); 2. 함수형 프로그래밍 함수형을 지향하여 프로그래밍 하는 방법 대상을 찾거나 변수를 생성하고 각 대상에 이벤트를 걸어주고 이벤트 핸들러 설정을 한다. 이때 핸들러 설정을 할때 함수를 중심으로 프로그래밍을 하는 방법이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(function(global, document) { 'use strict' var namespace ='y9'; function el(selector, context) { return (context || document).querySelector(selector); } function els(selector, context) { return (context || document).querySelector(selector); } function each(list, callback) { for(var i=0, l=list.length; i&lt;l; i++) {callback(list[i], i);} } function on(el, type, handler) { el.addEventListener(type, handler); } function off(el, type, handler) { el.removeEventListener(type, handler); } function hasClass(el, name) { return el.classList.contains(name); } function addClass(el, name) { var names = name.splice(' '); each(names, function(name) { el.classList.add(name); }); return el; } function removeClass(el, name) { name ? el.classList.remove(name) : (el.className = ''); return el; } function toggleClass(el, name) { return hasClass(el, name) ? removeClass(el, name) : addClass(el, name); } Object.defineProperty(global, namespace, { value: {} }); // 내보낼 함수를 추가 [el, els, on, off, hasClass, addClass, removeClass, toggleClass, each] .forEach(function(fn) { global[namespace][fn.name] = fn; }); Object.freeze(global[namespace]);})(window, document);","link":"/JS/jsOOP/"},{"title":"JS 값과 영역 &amp; 호이스팅&#x2F;스코프 체이닝","text":"JS 값과 영역 &amp; 호이스팅/스코프 체이닝 1. 값 복사 vs 값 참조 값 복사 불변 데이터의 경우 그 값이 복사된다. 숫자 값, 문자 값, 불리언 값, null, undefined 값 복사 종류 null undefined number string boolean 값 복사 검증 변수에 참조된 값이 변경되었을 때 다른 변수에 담긴 값이 변경되지 않았던 것은 값이 복사되었음을 의미한다. 값 참조 가변 데이터의 경우 그 값이 참조된다. 객체 유형( 객체, 배열, 함수 ) 값 참조 종류 object array function 값 참조 검증 변수에 참조된 값이 변경되었을 때 다른 변수에 담긴 값이 변경된다면 값이 참조되었음을 의미한다. 2. 함수 영역 vs 블록 영역 전역 가장 간단한 변수 영역은 소스 코드 상의 모든 곳에서 사용할 수 있는 전역 변수. 전역 변수는 많은 언어에서 나쁜 과늣ㅂ으로 취급되지만, 그런 경우에도 함수명이나 클래스 명은 대부분 전역에서 접근할 수 있다. 이름 공간을 사용하여 전역 영역에서 변수나 함수명이 충돌하는 것을 막을 수 있다. 함수 영역 대부분의 프로그래밍 언어는 함수 내에서만 유효한 지역 변수를 제공한다. 함수 영역을 사용하는 지역 변수는 함수가 반환되면 더 이상 사용할 수 없다. 블록 영역 알골과 그의 자손인 C, 그리고 그에 영향을 받은 많은 현대 언어들은 블록 단위 지역 변수를 지원한다. 블록 문 내부에 선언된 변수는 블록 영역에서만 접근 가능하다. 1234567891011121314let phone = 'iPhone';function scopefn() { let phone = 'Note'; console.log(phone); // 함수 영역 내에 있는 지역 변수}// 이때는 phone을 출력하면 함수내에 있는 Note 보다는 iphone을 출력한다.function scopefn2() { tablet = 'Note'; // 함수 내에 선언되지 않은 변수는 지역 변수로 처리 핮 ㅣ않는다. console.log(tablet); // 함수 영역 내에 있는 지역 변수}// 이때는 tablet을 출력하면 Note를 출력한다. 3. 호이스팅 / 스코프 체이닝 호이스팅(끌어 올려짐) ECMAScript 2015 언어 명세 및 그 이전 표준 명세에서 사용된 적이 없는 용어이다. 호이스팅 변수 및 함수 선언이 물리적으로 작성한 코드의 상단으로 옮겨지는 걸로 가르치지만, 실제로 그렇지 않다. 변수 및 함수 선언은 컴파일 단계에서 메모리에 저장되지만, 코드에서 입력한 위치와 정확히 일치한 곳에 있다. 변수 선언 -&gt; 초기화(값 할당) -&gt; 변수 허용 영역(Scope) 설정 어디에 선언이 되어 있든, 변수들은 코드가 실행되기 전에 처리가 된다. var로 선언된 변수의 범위는 현재 실행 컨텍스트인데, 그 컨텍스트를 둘러싼 함수, 혹은 함수의 외부에 전역으로 선언된 변수가 될 수 있다.","link":"/JS/jsValue/"},{"title":"JS Type &amp; 속성","text":"자바스크립트의 타입과 변수 선언 1. 인터랙션 디자인의 시작 - 문서객체가 가진 값 그리고 변수 자바스크립트 객체(object) HTML 문서에 작성된 요소를 브라우저 해석해서 객체화시킨다. 객체 및 속성 객체의 속성을 변경시 문자열로 바꿔주고 싶을 경우는 String(바꾸고 싶은 값), 숫자형으로 바꿔주고 싶을 경우는 Number(바꾸고 싶은 값), 2. javascript 데이터 타입 / 리터럴 데이터 타입 null undefined number string boolean(true, false) symbol (ES6+) 객체 데이터 유형 function object( f anoymous(){ } ) array object ( [] ) object ({}) 부동 소수점 리터럴 부호(‘+’나 ‘-‘)가 달릴 수 있는 10진 정수 소수점(“.”) 소수(또 다른 10진수) 지수 3. javascript 변수 네이밍 컨벤션 네이밍시 오류가 발생하는 원인 숫자로 시작하는 경우 밑줄(_), 달러 기호($)가 아닌, 다른 특수 문자 또는 공백이 사용되는 경우 4. 동적 형 지정 / 자동 형 변환 동적 형 지정123var total = 1568;var message = 'javascript';var show = false; 정적 형 지정(typescript)123var total:number = 1568;var message:string = 'javascript';var show:boolean = false; 자동 형 변환 숫자값이 문자로 변경되는 경우 문자 값을 숫자로 변경해야하는 경우 widow.parseInt(문자, 10); widow.parseInt(문자, 10); 불리언 값으로 변경되는 경우 !를 사용하여 형 불리언 값을 변경 가능하다.(!false -&gt; true) 5. 문서 객체의 ID 속성 이름 값 만으로 대상을 선택해서는 안되는 이유 (동일한 변수 이름 문제) js에서 id 값으로 선택해서 js 코드에서 불러오는데 이때 밑에서 변수선언으로 id값과 같은 이름으로 변수 선언시 위에서 사용한 id값으로 가져온 것은 오류로 띄워주게 된다.","link":"/JS/jsType/"},{"title":"HTML Element와 구조","text":"HTML Element와 구조 1. Element 구조 &lt;여는 태그&gt; 컨텐츠 &lt;/닫는 태그&gt; &lt;태그 이름 속성 = &quot;값&quot;&gt; 컨텐츠 &lt;/ 태그 이름&gt; 태그 안에 값은 “”권장 2. 콘텐츠를 감싸지 않은 요소 내용이 필요 없는 경우 여는 태그만 존재 3. 표준 호환모드 &lt;!doctype html&gt; 웹 표준을 설정함 표준호환모드로 변환 4. 문서에 사용되는 주 언어 설정 &lt;html lang=&quot;ko-KR&quot;&gt; 이런식으로 html에 언어를 설정해주면 시각장애인들을 위해 웹에서 해당언어로 읽어줄수 있게 설정해준다. 5. 제목과 단락 제목은 태그로 감싼다 단락은 태그로 감싼다 &lt;h1&gt;태그는 문서에서 하나만 작성 가능 6. HTML 이미지 &amp; 피규어 &amp; 캡션 도표나 이미지 차트 등을 감싸는 태그는 &lt;figure&gt;을 사용해서 감싸준다. 이미지태그는 &lt;img src=&quot;이미지 경로&quot; alt=&quot;이미지에 대한 설명&quot;/&gt; 으로 사용해준다. &lt;figcaption&gt;는 이미지에 대한 캡션을 작성해주는 태그이다. (사진 밑에 사진에 대한 설명) 7. HTML 문법 유효성 검사 (validator)validator.w3.org : 온라인으로 문법이 틀린곳이 없는지를 확인해주는 툴이다.사이트 사용법 URI를 사용하여 문법검사를 해주는 방법 File을 직접 업로드하여 문법검사를 해주는 방법 entitycode.com : html에 entitycode 설명이 나와있는 사이트 8. HTML 목록 디자인목록(lists) 비순차 목록 (순서가 중요하지 않은 목록)1234&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 순차 목록(순서가 중요한 목록)1234&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 9. 하이퍼링크(Hyperlink) anchor는 웹 페이지 내에서 다른 페이지 이동을 하지않고 현재 페이지 하단 부분으로 이동하는 것을 의미한다.123&lt;!--a태그를 사용하여 href값에 #태그와 id값을 다음과 같이 넣어주면 해당 id의 위치로 이동하게 된다.--&gt;&lt;a href=&quot;#id&quot;&gt;achor이동&lt;/a&gt;&lt;h3 id=&quot;id&quot;&gt;여기로&lt;/h3&gt; hyper link는 link가 이동되는 것을 의마한다.12&lt;!--a태그를 사용하여 href값에 이동할 링크값을 다음과 같이 넣어주면 해당 링크로 이동하게 된다.--&gt;&lt;a href=&quot;https://www.google.com&quot;&gt;구글 링크로 이동&lt;/a&gt; 10. 그룹 디자인다음과 같이 dl을 통해 그룹화를 해준후 dt요소와 dd요소를 사용해서 그룹화의 제목과 설명을 적어준다. 1234567891011121314&lt;!--설명목록 (Description Lists)--&gt;&lt;dl&gt; &lt;dt&gt;용어(Definition Term)&lt;/dt&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt; &lt;dt&gt;용어(Definition Term)&lt;/dt&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt; &lt;dt&gt;용어(Definition Term)&lt;/dt&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt; &lt;dd&gt;설명(Definition Description)&lt;/dd&gt;&lt;/dl&gt; 11. 인용문12345678910111213&lt;!--인라인 인용문--&gt;&lt;q&gt;짧은 인라인 인용문&lt;/q&gt;&lt;cite&gt;출처에서 가져온 구문&lt;/cite&gt;&lt;q cite=&quot;출처 주소&quot;&gt;&lt;/q&gt;&lt;!--꼭 q요소를 사용할 필요는 없고 &quot;&quot;를 사용해주어도 된다--&gt;&lt;!--중복 인용 가능--&gt;&lt;!--블록 인용구문--&gt;&lt;blockquote&gt; &lt;p&gt;글&lt;/p&gt; &lt;p&gt;글&lt;/p&gt; &lt;cite&gt;인용한 구문 출처&lt;/cite&gt;&lt;/blockquote&gt; 12. 줄바꿈(&lt;br&gt;) 단락으로 나누지 않고 줄 바꿈을 사용할 때 &lt;br&gt;을 두번 사용하지 말아야한다 13. 어휘에 사용 되는 요소들강조와 표현적인 목적으로 나눔 강조&lt;em&gt; : 특정 내용의 스트레스 강조 (문장 의미를 변경)&lt;strong&gt; : 내용의 중요성, 심각성, 긴급성을 강조할 경우 표현적인 목적&lt;b&gt; : 단순히 다른 글자와 구분된 용도로 사용, 문서 요약의 주요 단어, 리뷰 제품 이름 등&lt;i&gt; : 다른 글자와 구분된 용도로 사용, 기술적 용어, 다른 언어(목소리), 인물의 생각 등을 표현 14. 문서의 섹션 및 메인 요소 구조화섹션 요소에 포함되어있는 것&lt;header&gt;: 일반적으로 섹션의 제목, 목차(Nav), 검색, 로고 등을 포함하여 사용&lt;footer&gt;: 일반적으로 섹션의 저자, 링크, 저작권 정보 등을 포함하는데 사용 섹션 요소와 포함되어 있지 않음&lt;main&gt;: 일반적으로 주요페이지 요소들 사용 여러 번을 사용해도 상관없다. 12345678910&lt;!--잘못된 예시--&gt;&lt;section&gt; &lt;main&gt;&lt;/main&gt;&lt;/section&gt;&lt;!--올바르게 사용되는 예시--&gt;&lt;main&gt; &lt;section&gt; &lt;header&gt;&lt;/header&gt; &lt;/section&gt;&lt;/main&gt; 다음과 같은 구조로 크게 나뉜다. 123456789101112131415161718192021&lt;body&gt; &lt;header&gt; &lt;nav&gt;&lt;/nav&gt; &lt;/header&gt; &lt;aside&gt;&lt;!-- 웹 사이트의 사이드바에 해당되는 부 콘텐츠 섹션을 가르킨다.--&gt; &lt;/aside&gt; &lt;main&gt; &lt;section&gt; &lt;!--일반적인 컨테이너 요소가 아니며, 문서 개요에 명시적으로 나열되는 경우에만 섹션 요소가 적합하다는 규칙이 있다. --&gt; &lt;article&gt;&lt;!--문서 페이지 애플리케이션 사이트 등에 포함된 독립적인 섹션을 말한다.--&gt;&lt;!--일반적인 규칙은 article요소의 내용이 문서 개요에 명시적으로 나열되는 경우에만 적합하다. 제목(h1~h6요소)를 꼭 포함시켜야 한다.--&gt; &lt;h2&gt;꼭 article 내부에는 heading 필요~!!&lt;/h2&gt; &lt;/article&gt; &lt;/section&gt; &lt;/main&gt; &lt;footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;/footer&gt;&lt;/body&gt; 15. 컨테이너 요소아무런 의미를 가지지 않는 요소들에 사용&lt;div&gt;: 블럭 컨테이너&lt;span&gt;: 인라인 컨테이너 16. 텍스트 레벨 시멘틱 요소&lt;sup&gt; : 윗첨자 시 사용 12345678910111213141516171819202122232425262728293031&lt;p&gt;각주&lt;sup&gt;&lt;a href=&quot;#movehear&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;div id=&quot;movehear&quot;&gt;각주엗 대한 설명&lt;/div&gt;``` `&lt;sub&gt;` : 아래첨자 시 사용 ```html&lt;dfn&gt;H&lt;sub&gt;2&lt;/sub&gt;SO&lt;sub&gt;4&lt;/sub&gt;&lt;/dfn&gt;``` `&lt;mark&gt;` : 검색을 할 때 검색어가 **하이라이트** 되는 부분 ```html&lt;span&gt; 해당 부분 &lt;mark&gt;강조&lt;/mark&gt; 및 &lt;mark&gt;하이라이트&lt;/mark&gt; 처리 됨 &lt;/span&gt;``` `&lt;abbr&gt;` : 축약 요소(줄임말에 대해 설명하는 요소) ```html&lt;h2&gt;&lt;abbr title=&quot;맥도날드&quot;&gt;맥날&lt;/abbr&gt;&lt;/h2&gt;``` `&lt;time&gt;` : 기계가 이해할 수 있는 형태로 날짜나 시간을 나타내는 요소 ```html&lt;span&gt; &lt;time pubdate=&quot;2020-06-25&quot;&gt;Jun 25, 2020&lt;/time&gt;&lt;/span&gt;``` `&lt;s&gt;` : 더 이상 관련이 없거나 더 이상 정확하지 않은 요소(쇼핑몰에서 가격 할인시 가격에 줄이 가있는 것) ```html&lt;p&gt; &lt;span class=&quot;hidden-text&quot;&gt;원래 가격&lt;/span&gt;&lt;s&gt;11,900원&lt;/s&gt; &lt;em&gt;50%&lt;/em&gt;&lt;span class=&quot;hidden-text&quot;&gt;할인&lt;/span&gt; 5,900원&lt;!--웹페이지에서 알수 있도록 time요소와 data요소 사용--&gt; &lt;p&gt;&lt;time datetime=&quot;2020-06-25&quot;&gt;오늘마감&lt;/time&gt; &lt;data value=&quot;7&quot;&gt;7개&lt;/data&gt;구매 &lt;/p&gt;&lt;/p&gt; &lt;data&gt; : 댓글과 같은 갯수들을 나타낼때 감싸주는 요소 1&lt;span&gt;댓글 &lt;data value=&quot;0&quot;&gt;0&lt;/data&gt;&lt;/span&gt; 17. 그룹핑(Grouping) 요소&lt;address&gt; : 조직의 정보를 담는 요소(footer에서 주로 사용) 123456789101112131415&lt;address&gt;서울시 서초구 방배로00길 00전화: &lt;a href=&quot;tel:02-000-000&quot;&gt;02-000-0000&lt;/a&gt;&lt;/address&gt;``` `&lt;pre&gt;` : 이메일, 빈 줄이 표시된 단락, 글 머리표가 붙은 줄로 표시된 목록 등에 사용, 컴퓨터 코드(아스키 코드 등) 표시 목적으로 사용 ```html&lt;!--코드를 다음과 같이 pre 요소로 감싼 후 code 요소로 감싸주면 사용 가능--&gt;&lt;pre&gt; &lt;code&gt; const code = () =&gt; { code function } &lt;/code&gt;&lt;/pre&gt; 18. 임베디드(Embedded) 요소01. HTML 픽쳐(Picture) 요소&lt;picture&gt; 요소 0개 이상의 &lt;source&gt; 요소와 1개 이상의 를 포하맣는 컨테이너 요소 다양한 스크린 환경에 맞는 적합한 이미지를 제공하기 위한 목적으로 사용 최신브라우저에서는 &lt;source&gt;를 인식하면 &lt;source&gt;요소에 대한 정보를 표시, 인식하지 못하는 경우는 &lt;img&gt;요소를 사용123456789101112131415161718192021222324252627282930313233343536&lt;!--media 속성--&gt;&lt;picture&gt; &lt;source srcset=&quot;사진.png&quot; media=&quot;(min-width: 600px)&quot;&gt; &lt;img src=&quot;사진.png&quot; alt=&quot;사진에 대한 설명&quot;&gt;&lt;/picture&gt;&lt;!--type 속성--&gt;&lt;picture&gt; &lt;source srcset=&quot;사진.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;img src=&quot;사진.png&quot; alt=&quot;사진에 대한 설명&quot;&gt;&lt;/picture&gt;``` `&lt;source&gt;` 요소- `&lt;picture&gt;`, `&lt;audio&gt;`, `&lt;video&gt;` 요소의 다중 미디어 리소스를 지정하기 위해 사용. - 여러개 사용 가능 - media 속성을 사용하여 반응형 웹을 사용할 수 있다. ### 02. HTML 비디오(Video) 요소`&lt;video&gt;` 요소 - 동영상 콘텐츠를 포함하기 위해서 사용.- src 속성이나 `&lt;source&gt;` 요소을 이용해 여러 개의 동영상 소스 중 하나를 표시.- mp4를 사용하면 요즘 모든 브라우저에서 사용 가능하기 때문에 따로 `&lt;source&gt;`요소를 사용하지 않아도 된다.- 속성 - src : 비디오 파일 경로 - poster : 포스터 이미지 경로 - preload : auto(기본값) 브라우저를 미리 읽어와서 사용자 경험을 향상시키는데 목적이 있음 - controls : 재생 컨트롤러 표시 설정 - autoplay : 자동 재생 설정 - loop : 반복 설정 - mute : 소리 꺼짐```html&lt;video src=&quot;비디오 path 작성&quot; poster=&quot;비디오 포스터 path&quot; muted&gt; &lt;p&gt; HTML5 &lt;code&gt;video&lt;/code&gt; 요소를 지원하지 않는 구형 웹 브라우저를 사용 중입니다. &lt;a href=&quot;http://outdatedbrowser.com/ko&quot;&gt;최신형 브라우저로 업데이트&lt;/a&gt; 하세요. &lt;/p&gt;&lt;/video&gt; 03. HTML 오디오(Audio) 요소&lt;audio&gt; 요소 오디오는 controls 속성을 사용하여 표시해 주어야 한다. mp3를 사용하면 요즘 모든 브라우저에서 사용 가능하기 때문에 따로 &lt;source&gt;요소를 사용하지 않아도 된다. 보통은 다음과 같이 사용해준다. 123456789101112131415161718192021222324252627&lt;figure&gt; &lt;img src=&quot;이미지 path&quot; alt=&quot;img 설명&quot;&gt; &lt;figcaption&gt; &lt;audio src=&quot;오디오 path 작성&quot; controls&gt; &lt;p&gt; HTML5 &lt;code&gt;video&lt;/code&gt; 요소를 지원하지 않는 구형 웹 브라우저를 사용 중입니다. &lt;a href=&quot;http://outdatedbrowser.com/ko&quot;&gt;최신형 브라우저로 업데이트&lt;/a&gt; 하세요. &lt;/p&gt; &lt;/audio&gt; &lt;/figcaption&gt;&lt;/figure&gt;``` ### 04. HTML 트랙(Track) 요소`&lt;track&gt;` 요소 - 비디오, 오디오 재생 시, 자막을 표시- 실제 서버에서만 자막을 출력가능```html&lt;video src=&quot;비디오 path&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;자막 path&quot; srclang=&quot;ko&quot; label=&quot;한국어&quot; default&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;자막 path&quot; srclang=&quot;en&quot; label=&quot;영어&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;오디오 path&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;자막 path&quot; srclang=&quot;ko&quot; label=&quot;한국어&quot; default&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;자막 path&quot; srclang=&quot;en&quot; label=&quot;영어&quot;&gt;&lt;/audio&gt; 05. HTML 인라인 프레임(iframe) 요소&lt;iframe&gt; 요소 인라인 프레임에 다른 HTML 페이질르 포함하여 화면에 표시 (구글 맵이나 유투브등) 속성 src: 프레임 소스 설정 width : 프레임 너비 설정 height : 프레임 높이 설정 allowfullscreen : 프레임 전체화면 설정 06. HTML 이미지 맵(map) 요소&lt;map&gt; 요소 이미지 앱(클릭 가능한 링크 영역)을 정의하기 위해 &lt;area&gt;와 함께 사용됨. 눈에 보이지 않음 &lt;area&gt; 요소 이미지의 핫스팟 지역 정의, 하이퍼링크 설정. &lt;map&gt; 내부에서만 사용 가능. 이미지에 좌표 생성 도구 (https://www.image-map.net) 속성 shape coords href target alt hreflang download 123&lt;map name=&quot;map에 이름&quot;&gt; &lt;area shape=&quot;모양 설정&quot; coords=&quot;좌표&quot; href=&quot;눌렀을때 이동할 사이트&quot; alt=&quot;사이트 설명&quot;&gt; &lt;/map&gt; 07. HTML 확장 가능한 벡터그래픽(SVG) 요소&lt;svg&gt; 요소 확장가능한 백터 그래픽은 2차원의 백터 그래픽을 기술하기 위한 XML 마크업 언어. 19. 표 디자인&lt;table&gt; 요소 테이블 몸체에 해당되면, 행/열 및 셀을 포함한다. 복잡한 내용을 x,y축에 따라 이해하기 쉽게 데이터를 구조화하는데 테이블을 사용한다. 테이블 내에 테이블 중첩사용은 안된다. 테이블을 레이아웃 목적으로 사용해서는 안된다. area-describedby속성을 사용하여 자세한 설명과 연결해줄수 있다. 또는 &lt;figure&gt;요소에 aria-labelleby 속성을 사용해 제목(caption)을 연결해줄수 있다. &lt;table&gt; 요소 안에는 &lt;tr&gt;요소와 &lt;caption&gt;요소를 갖을 수 있다. &lt;tr&gt; 요소 테이블의 행을 가르킨다. &lt;tr&gt;요소는 &lt;th&gt;와 &lt;td&gt;를 갖을 수 있다. &lt;th&gt; 요소 테이블 셀 제목 속성 scope : 행 또는 열, 행그룹, 열그룹의 제목임을 명시 colspan: 열을 그룹 지을때 사용 rowspan: 행을 그룹 지을때 사용 &lt;tr&gt; 요소 테이블 셀 내용 속성 headers : 셀 제목을 하나 이상 연결하여 읽기 용이하도록 구성할 때 사용 colspan: 열을 그룹 지을때 사용 rowspan: 행을 그룹 지을때 사용 &lt;col&gt; 요소 테이블 열을 하나 이상 묶고자 할 때 사용한다. 일반적으로 colgroup 요소 내부에 포함시킨다. 속성 span : 열 묶음 개수 설정 &lt;colgroup&gt; 요소 테이블 열을 그룹을 만들고자 할 때 사용한다. 내부에 col요소를 포함하거나, 포함하지 않을 수 있다. 속성 span : colgroup 요소가 col을 포함하지 않을 경우, 열 묶음 개수 설정 20. 폼 디자인&lt;form&gt; 요소 폼은 텍스트필드, 버튼, 체크박스와 같은 폼 컨트롤을 포함하는 웹페이지의 컴포넌트를 말한다. 사용자와 인터렉션을 수행한 결과 (예: 검색)를 서버로 보낼 수 있다. &lt;label&gt; 요소 속성 for : &lt;input&gt;요소의 id 값과 동일하게 만들면 해당 요소의 label이 된다. &lt;input&gt; 요소 사용자의 데이터를 받을 수 있는 폼 컨트롤을 말한다. 다양한 유형 설정이 가능하며, 유형에 맞는 역할을 수행한다. 속성 name placeholder value readonly required disabled minlength maxlength list type text password checkbox radio file submit button image reset hidden search url tel email date month week time datetime-local number range color &lt;button&gt; 요소 버튼 폼 컨트롤로 사용자의 인터렉션을 받아 액션을 트리깅 처리한다. type submit button reset &lt;select&gt; 요소 드롭 다운 메뉴 컨트롤을 말한다. 내부에 &lt;option&gt;요소를 포함하여 사용자에게 선택할 수 있도록 한다. &lt;option&gt;요소를 묶어 그룹으로 만들고자 한다면 &lt;optgroup&gt;요소를 사용하고 &lt;label&gt;속성을 사용해 그룹 이름을 설정한다. 속성 name multiple disabled required size &lt;textarea&gt; 요소 멀티라인 일반 텍스트 편집 컨트롤을 말한다. 속성 name placeholder rows cols readonly required disabled minlength maxlength &lt;filedset&gt; 요소 하나 이상의 폼 컨트롤을 그룹화 하는데 사용됨 속성 name disabled &lt;legned&gt; 요소 &lt;filedset&gt; 컨트롤의 레이블을 설정하는 컨트롤 &lt;output&gt; 요소 계산된 결과를 출력하는 컨트롤 속성 name for &lt;datalist&gt; 요소 데이터 목록 요소 컨테이너 컨트롤 내부에 &lt;option&gt; 요소를 사용해 항목을 만든다. &lt;progress&gt; 요소 작업의 완료 진행 상황을 표시하는데 사용되는 컨트롤 속성 value max &lt;meter&gt; 요소 알려진 범위 내에서의 스칼라 측정 또는 분포 비율을 나타내는 컨트롤 (게이지라고도 부른다.) 디스크 사용 현황, 쿼리 결과의 관련성, 특정 후보에 대한 투표율 등이 해당됨. 속성 value max min low high optimum 21. 인터랙티브 요소(, , )&lt;details&gt; 요소 디스클로저 위젯으로 정보를 감추거나, 펼처서 보여준다. 모든 정보를 일시에 고액하지 않고 사용자의 요구에 맞춰 정보를 공개할 수 있다. 아코디언 컴포넌트와 비슷하게 작동한다. 속성 open : 페이지 로딩 시, 위젯을 표시하도록 설정 &lt;summary&gt; 요소 &lt;details&gt; 요소의 레이블/ 제목(캡션), 요약(서머리) 등을 표시한다. 폼 &lt;filedset&gt; 요소의 제목을 &lt;legend&gt; 요소가 표시하듯 비슷하다. &lt;dialog&gt; 요소 사용자의 결정 또는 정보 입력을 요구하는 컴포넌틀를 말함. ‘모달 윈도우’ 또는 대화상자로도 불린다. 속성 open : 페이지 로딩 시, 위젯을 표시하도록 설정 22. 스크립팅 요소들&lt;script&gt; 요소 JS 코드 또는 파일을 HTML 문서에 작성하거나, 연결할 때 사용한다. 속성 src type async defer &lt;noscript&gt; 요소 사용자의 웹 브라우저 환경에서 스크립트를 지원되지 않거나, 스크립트가 꺼져있는 경우, 문서에 표시될 문구를 삽입한다. &lt;canvas&gt; 요소 JS를 사용하여 그래픽을 그릴 떄 사용한다. 2D 또는 WebGL 컨텍스트 객체를 추출해 그래픽을 그릴 수 있다. 23. 사용자와 상호작용하는 속성(인터랙티브 요소)hidden 속성 &lt;div&gt; 요소 안에 속성으로 hidden을 넣어 놓으면 화면에서는 보이지 않는다. JS를 통해 조작 가능하다. tabindex 속성 요소를 키보드로 탐색할 수 있도록 설정하거나, 제외 또는 순서대로 탐색할 수 있도록 설정할 수 있다. 속성값으로 0을 주면 비포커스 요소(&lt;div&gt; 등)에 포커스를 적용해야 할 경우 사용된다. 속성값으로 -1을 주면 포커스 순서에서 제외시킬 수 있다. 기본적 포커스 가능한 요소들 폼컨트롤 요소 : &lt;input&gt;, &lt;button&gt;, &lt;textarea&gt;, &lt;select&gt; 등 href 속성을 가진 요소 : &lt;a&gt;, &lt;area&gt; controls 속성을 가진 요소 : &lt;video&gt;, &lt;audio&gt; accesskey 속성 모든 HTML 요소는 accesskey 속성을 가질 수 있다. 속성 값은 키보드 단축키로 설정된다. accesskey 속성의 단축키는 브라우저와 운영체제 플랫폼에 의존하고 있어 운영체제마다 단축키가 달라진다. contenteditable 속성 설정된 요소는 사용자가 직접 편집할 수 있도록 만들어 준다. ture(“””) or false로 설정하고 false면 사용자가 수정하지 못하고 빈문자열이나 true일 때는 수정 가능하다. draggable 속성 drag가능","link":"/HTML/htmlElement/"},{"title":"React Props &amp; State","text":"React Props &amp; State 1. React 컴포넌트와 전달 속성(props) React 컴포넌트로 props를 전달할 수 있다. 상위 컴포넌트에서 하위 컴포넌트로 props를 넘겨주는데 이때 상위에서 데이터를 다음과 같이 전달해 준다. 1234567891011121314151617181920212223// React Componentfunction MenuListItem(props) { return &lt;li&gt; &lt;h3&gt;{props.caption}&lt;/h3&gt; &lt;/li&gt;}// 위의 컴포넌트를 아래에서 사용function MenuList() { // 다음과 같이 Props를 전달해고 위에서처럼 값을 전달 받을수 있다. return &lt;ul&gt; &lt;MenuListItem caption = &quot;props 전달 1&quot; /&gt; &lt;MenuListItem caption = &quot;props 전달 2&quot; /&gt; &lt;/ul&gt;}// 위의 컴포넌트를 아래에서 사용function App() { return &lt;main&gt; &lt;h2&gt;&lt;/h2&gt; &lt;MenuList/&gt; &lt;/main&gt;} 2. 컴포넌트 &amp; props 컴포넌트 UI를 구성하는 조각에 해당되며, 독립적으로 분리되어 재사용을 목표로 사용한다. React 앱에서 컴포넌트는 개별적인 JavaScript 파일로 분리되어 관리한다. React 함수형 컴포넌트 함수형 컴포넌트 React 컴포넌트는 개념상 JavaScript 함수와 유사하다. 컴포넌트 외부로부터 속성(props)을 전달 받아 어떻게 UI를 구성해야 할지 설정하여 React요소(JXL를 Babel이 변환 처리)로 반환된다. 문법 구문을 사용하는 컴포넌트를 React는 함수형으로 분류한다. 컴포넌트 이름은 항상 대문자로 시작하는 TitleCase문법 사용이 권징된다. (HTML 표준 요소와 구별하기 위함) React 클래스 컴포넌트 ES6부터 지원됨 vsCode에서 React pure to Class를 선택해주면 함수형 컴포넌트를 class형 컴포넌트로 나눌수 있다. 클래스 컴포넌트 vs 함수형 컴포넌트 React에서는 두 컴포넌트는 유사하다. 클래스 컴포넌트의 경우 함수형 컴포넌트에 없는 기능을 추가적으로 사용 가능하다. React 컴포넌트 import,export / props 다른 파일로 자식 컴포넌트 분리 후 export로 파일 저장 -&gt; import로 자식 컴포넌트를 부모 컴포넌트에서 불러온다. props(전달속성) 컴포넌트에서 설정된 임의의 JSX 속성(type, children 등)은 React에 의해 컴포넌트 속성(props) 객체로 전달한다. 부모 -&gt; 자식으로 데이터를 넘길 때 사용(부모에서 props로 데이터를 넘김) 컴포넌트에 전달된 속성 객체는 읽기전용이라 수정이 불가능하다. 이때 수정을 하기위해서는 props 대신 state를 활용해야한다. React 컴포넌트 관리 (추출) 컴포넌트 트리 최상위 부모에는 App파일이 되어야하고 그안에 여러 컴포넌트를 나눠 중복 또는 반복되는 부분을 바꾸어 주어야한다. 컴포넌트 추출 컴포넌트 내부에서 컴포넌트로 사용할 수 있는 것이 보인다면 분리하는 것이 좋다. 복잡한 컴포넌트 내부에서 세분화하여 분 가능한 컴포넌트로 나눠 구성하여 관리하는게 좋다. 컴포넌트 구조가 복잡한 경우, 요청사항에 따라 변경이 까다로울 수 있고 부품을 재사용하기 어렵다. 컴포넌트를 작게 나눠 재사용하는 용도로 구분해 개발하는것이 좋다. 3. props 검사 JavaScript 타입 검사JavaScript는 동적 타입을 사용하는 프로그래밍 언어로 자유도가 높은점이 장점이면서 단점이다. 단점 데이터 타입이 잘못 전달된 경우 문제가 발생해도 오류를 알려주지 않는다. 오류를 알려주지 않기 때문에, 이러한 문제 해결을 위해 함수를 제작할 때 전달 인자의 유효성을 직접 검사해야한다. PropTypes를 활용해 컴포넌트 props 검사React 속성 타입 검사 - 이번 섹션에서 다루는 PropTypes는 규모가 큰 개발일 경우 적합하지 않습니다. - 규모가 큰 경우 Flow 또는 TypeScript를 사용할 것을 권하고 있다.prop-types 패키지 - 설치 npm i prop-types - import로 설치한 prop-types를 불러와주고 자식 속성에서 필요한 데이터의 propType을 설정해주어야 한다. 123456className.propTypes = { name: PropTypes.string.isRequired, // 문자형 필수 number: PropTypes.number.isRequired, // 숫자형 필수 function: PropTypes.func.isRequired, // 함수형 필수 boolean: PropTypes.bool.isRequired, // 불리언 형 필수} 타입 검사 방법 모든 타입 PropTypes.any Number 객체 PropTypes.number string 객체 PropTypes.string Boolean 객체 PropTypes.bool Function 객체 PropTypes.func Array 객체 PropTypes.array Object 객체 PropTypes.object Symbol 객체 PropTypes.symbol Node 객체 PropTypes.node React 객체 PropTypes.element 여러 타입 중 하나 PropTypes.oneOfType([PropTypes.number, PropTypes.string]) 특정 클래스의 인스턴스 PropTypes.instanceOf(Date) 전달 속성 제한 PropTypes.oneOf([‘name’, ‘career’]) 특정 타입 집합으로 제한 PropTypes.arrayOf(PropTypes.string) 특정 타입을 속성 값으로 하는 객체 제한 PropTypes.objectOf(PropTypes.number) 특정 형태를 갖는 객체 제한 PropTypes.shape({prop1, prop2}) PropTypes 속성 기본 값 설정JavaScript(ES6)에서 매개변수 기본 값 매개변수로 값을 전달해 주지 않을 때 message를 매개변수로 받으면 ‘안녕하세요’라는 값을 기본값으로 받는다. React 전달 속성 기본 값 설정 컴포넌트에 전달될 속성의 기본 값을 설정할 때에는 defaultProps속성을 사용하여 기본값을 설정해줄 수 있다. 123456789101112131415161718// 함수 필드 사용시class.defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값}// class 필드 사용시class Class extends Component { // 기본값 설정 static defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값 }} 4. state &amp; 라이프 사이클 훅 클래스 컴포넌트의 state 란? 컴포넌트는 외부로 부터 속성(Props)을 전달 받아 사용할 수 있지만, 전달 받은 속성은 읽기 전용으로 값을 업데이트할 수 없다. state는 컴포넌트가 소유한 로컬 데이터로 적용 범위는 현재 컴포넌트에 한정된다. 필요한 경우, 컴포넌트는 자신의 state를 초기화 하거나 업데이트 할 수 있다. 컴포넌트 라이프 사이클 훅(Life Cycle Hooks) 이란? 생성 will/did -&gt; 업데이트 will/did -&gt; 삭제 will/did Render 단계 (순수하고 부작용이 없다. React에 의해 일시 중지, 중단 또는 재시작 가능) constructor(생성) -&gt; getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render(생성, 업데이트) getDerivedStateFromProps 단계에서 업데이트시 New Props, setState(), forceUpdate() 사용가능 Commit 단계 (DOM을 사용하여 부작용을 실행하고 업데이트를 예약 가능) React DOM 및 refs 업데이트 생성시(componentDidMount), 업데이트시(componentDidUpdate), 제거시(componentWillUnmount) 생성 시점의 라이프 사이클 훅 라이프 사이클의 3단계 Mounting -&gt; 생성 Updating -&gt; 갱신 UnMounting -&gt; 제거 마운팅 시점 라이프 사이클 훅 설명 constructor() 컴포넌트 생성 시점에 호출 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출 render() 컴포넌트 렌더링 시점에 호출 componentDidMount() DOM에 마운트 된 이후 시점에 호출 업데이트, 제거 시점의 라이프 사이클 훅 업데이팅 라이프 사이클 훅 설명 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출(업데이트) shouldComponentUpdate(nextProps, nextState) 컴포넌트 업데이트 예정 시점에 호출(업데이트 하거나, 안하거나) render() 컴포넌트 렌더링(업데이트) getSnapshotBeforeUpdate() 컴포넌트 업데이트 전 스냅샷 가져오는 시점에 호출 componentDidUpdate() 컴포넌트 업데이트 이후 시점에 호출 state 업데이트 React state는 불변 객체이다. React는 state에 변경 대신, 새롭게 교체하는 방법을 사용해 불변 객체를 유지한다. 오류 발생 시점의 라이프 사이클 훅 컴포넌트 렌더링, 라이프 사이클 훅이 실행될 때 오류가 발생한 경우 호출 라이프 사이클 훅 설명 static getDerivedStateFromError() 자손 컴포넌트 오류 발생 시 호출 componentDidCatch() 자손 컴포넌트 오류 발생 시 호출 1234567891011121314state = { hasError: false }// 자식 컴포넌트의 오류를 throw한 후 실행static getDerivedStateFromError(error) { // throw된 오류가 감지되면, hasError 상태 값을 true처리 return { hasError: true }}render() { // 오류 발생시, 레더링 과정에서 오류 메시지를 반환 this.state.hasError &amp;&amp; &lt;h1&gt;오류 발생&lt;/h1&gt; return &lt;div/&gt;}","link":"/React/reactComponent/"},{"title":"React Context","text":"React Context와 고차 컴포넌트(HOC) 컨텍스트(Context)1. Context의 Provider, Consumer를 사용한 데이터 공유 Context는 React 컴포넌트 트리안에서 데이터를 글로벌하게 공유할 수 있도록 고안된 방법이다. Context의 Provider는 데이터를 가지고 있는 부모 컴포넌트를 뜻하고 Consumer는 데이터를 받고 싶은 자식 컴포넌트를 뜻한다. 사용 방법12345678910// Context 생성하고 초기값을 설정const Context = React.createContext(false);// 부모 컴포넌트에서 보내줄 데이터 설정&lt;Context.Provider value={this.state.value} /&gt;// 자식 컴포넌트에서 값 받기&lt;Context.Consumer&gt;&lt;/Context.Consumer&gt; 다른 파일에서 사용시에는 export를 사용해서 내보내준다. 2. Context 모듈을 활용해 개별 컴포넌트에서 데이터 공유 Context 분리 및 변경 메서드를 가진 context를 관리하는 파일을 생성한다. 부모, 자식 컴포넌트에서 분리한 context를 import하여 똑같이 사용해주면 된다. 3. Context Type 활용 Context Type은 컨텍스트 객체를 클래스 컴포넌트의 ContextType Static 속성으로 지정해 활용하는 방법이다. this.context를 사용해서 접근 가능 Context Type 사용하면 Context.Consumer를 생략하고 this.context를 사용해서 데이터를 빼와서 사용 가능하다. 그러나 공급자인 context.Provider는 생략 불가하다. Context Type을 사용하면 단 하나의 컨텍스트 객체만 사용 가능하다. 하나 이상의 컨텍스트 객체를 Context.Consumer를 중첩 사용해야한다. 자세한 Context에 대한 내용 참고 고차 컴포넌트(HOC)1. 고차 함수(HOF)란? 고차 함수의 조건 함수형 프로그래밍에서 함수는 값(Value)으로 취급된다. 함수에 숫자, 문자, 데이터를 전달하듯 함수 또한 다른 함수에 값으로 전달할 수 있다. 함수를 값으로 반환하는 것도 가능하다. 하나 이상의 함수를 인자로 전달 받는다. ((fn) =&gt; {}) 함수를 결과로 반환 한다. (() =&gt; fn) React에서는 Array의 map() 매서드가 고차함수이다. 2. 고차 컴포넌트(HOC)란? 고차 컴포넌트는 컴포넌트 로직을 재사용하기 위한 React 고급 프로그래밍 기술이다. 컴포넌트를 전달받아 새로운 컴포넌트를 반환하는 함수이다. 일반 컴포넌트가 UI를 반환하지만, 고차 컴포넌트는 컴포넌트를 반환한다. HOC는 Redux connect 함수, React Router withRouter 함수, Relay createFragmentContainer 함수 등 다양한 React 라이브러리에서 일반적으로 사용된다. 3. 사용자 정의 고차 컴포넌트 컴포넌트에서는 class 컴포넌트를 사용하여서 context를 불러와야한다.","link":"/React/reactContext/"},{"title":"React","text":"React 공부 순서 React 기초 React Props와 State React JSX React 이벤트 핸들러와 컴포넌트 통신 React Context &amp; 고차 컴포넌트 React 폼 컨트롤러 React 훅(Hook)과 접근성","link":"/React/index/"},{"title":"React Event &amp; Component","text":"React 이벤트 핸들링 &amp; 컴포넌트 통신 React 이벤트 핸들링1. React 이벤트 핸들링 React 요소에서 이벤트를 핸들링 하는 방식은 DOM 요소의 이벤트를 핸들링 방식과 유사하다. 문법적인 차이 이벤트 속성 이름은 camelCase 형식으로 작성 속성 값에 문자열 대신 JSX 형식으로 메서드를 연결(ex: onClick ={ onClickHandler } ) 브라우저 기본 동작을 중단하려면 반드시 e.preventDefault()를 사용 이벤트 핸들러 종류 2. React 이벤트 핸들러와 this e.preventDefault() 메서드 사용 시 this 참조에 대해 주의가 필요하다. 12345constructor(props) { super(this) // 클래스(인스턴스)의 메서드가 클래스(인스턴스)를 가리키도록 바인딩 처림 this.handleLinkClick = this.handleLinkClick.bind(this)} 컴포넌트 통신1. React 컴포넌트 간 통신이 필요한 이유 React 클래스 컴포넌트는 컴포넌트 내에서만 접근 가능한 상태(State)를 가질 수 있어 관리가 용이하지만, 컴포넌트가 중첩되더라도 각 컴포넌트마다 개별적으로 상태를 관리하므로 상태를 공유하는 것이 까다롭다. React 프로그래밍에서는 각 컴포넌트의 상태(데이터)가 스코프 체인 되지 않는다. 효과적인 상태를 관리하기 위해 React 프로그래밍에서는 부모컴포넌트가 상태를 관리하고, 자손 컴포넌트는 부모 컴포넌트와 통신하여 상태 공유를 처리한다. 2. 부모 컴포넌트와 자식 컴포넌트 사이의 props ⇌ callback 부모가 자식 컴포넌트에게 보낼때는 Props 속성을 사용해서 데이터를 전송 (메서드 전송) 자식이 부모 컴포넌트에게 보낼때는 callback을 사용해서 데이터를 전송 (메서드 실행) callback으로 함수를 자식컴포넌트로 전달하여 부모 컴포넌트에서 전달된 함수 데이터를 받는다. 3. 복잡한 컴포넌트 트리 구조에서 props ⇌ callback의 문제 React는 부모에서 자식 컴포넌트로 데이터를 내려오는 구조를 갖고 있기 때문에 복잡한 컴포넌트가 만들어 지면 props와 callback 지옥에 빠질 수 있다. 만약 원하는 데이터를 삭제할 시 해당 데이터를 불러오는 컴포넌트에서 함수를 만들어 준 후 props로 자식 컴포넌트에게 내려주어야 한다. 4. 상태 관리를 효율적으로 관리하기 위한 방법 Context, React Redux Context 활용 React는 중첩된 컴포넌트의 데이터 공유 문제를 해결하기 위한 방법으로 컨텍스트(Context)를 제공한다. Context 사용시 컴포넌트 트리로 묶인 컴포넌트 간에 데이터 공유가 수월해진다. 단점은 컴포넌트를 재사용하기 어렵게 만들기 때문에 꼭 필요한 경우에만 사용하는 것이 좋다. 컨텍스트의 단점을 보안하는 라이브러리 컨텍스트가 완벽한 프로그램이 아니기 때문에 각 컴포넌트가 소유하는데서 기인된 문제 해결 방안으로 상태 관리 시스템인 하나의 저장소에서 관리하도록 만드는 것이다. 다음과 같이 하나의 저장소에서 데이터를 관리 시 각 컴포넌트에서 데이터를 접근하는 여러가지 문제를 해결할 수 있다. 대표적인 상태 관리 라이브러리로 Redux와 Mobx, Vuex 등이 있다.","link":"/React/reactEvent/"},{"title":"React 폼 컨트롤러","text":"React 폼 컨트롤러 HTML VS React 폼 컨트롤 HTML Form 컨트롤러 방식 &lt;input/&gt;, &lt;textarea/&gt;, &lt;select/&gt; 등 사용자의 입력 콘텐츠를 자체적으로 관리한다. React Form 컨트롤러 방식 React는 컴포넌트 상태 정보를 state 속성으로 관리하며 setState()메서드를 사용해 상태를 업데이트한다.12// 다음과 같이 사용하여 입력한 value가 바로 state에 업데이트 되도록하여 입력한 값이 보이도록 하였다. &lt;input type=&quot;text&quot; value={this.state.inputValue}/&gt; AppInput 컴포넌트 (사용자 정의) 좀 더 자세한 Form에 대한 설명 input Form 컨트롤러를 따로 컴포넌트로 분리하여 사용한다. React 폼 멀티플 컨트롤 핸들링 하나의 컴포넌트를 사용하여 여러 input 컴포넌트를 생성하여 하나의 핸들러로 여러개를 관리할수 있다. &lt;textarea&gt; 컨트롤러 HTML의 &lt;textarea&gt;요소는 사용자가 입력한 내용을 자식 텍스트 콘텐츠로 받는다. React는 value 속성을 대신 사용하여 텍스트를 받아와야한다. 한줄 입력을 사용하는 폼 컨트롤러와 비슷하게 사용한다. 컨트롤 vs 언 컨트롤 컴포넌트, ref 속성 Uncontrolled 컴포넌트 컴트롤 할 수 없는 컴포넌트는 form요소가 React 외부에서 작동하는 것처럼 작동한다. 사용자가 form 필드(input box, dropdown 등)에 데이터를 입력하면 업데이트 된 정보가 React에서 별도 처리할 필요 없이 요소에 반영된다. File 인풋 요소 HTML에서 &lt;input type=&quot;file&quot; /&gt; 요소는 사용자가 하나 이상의 파일을 자신의 로컬 컴퓨터에서 서버로 업로드한다. 이 컴포넌트는 프로그래밍 적으로 값을 설정할 수 없고, 사용자만이 값을 설정할 수 있기 때문에 컨트롤 할 수 없는 컴포넌트 즉, 언 컨트롤 컴포넌트이다. 이때 컨트롤 할 수 없는 컴포넌트의 경우 DOM 자체에서 폼 데이터를 다루게 된다. 모든 state업데이트에 대한 이벤트 핸들러를 작성하는 대신 제어할 수 없는 컴포넌트를 만들려면 ref 속성을 사용해 DOM에서 폼 값을 가져올 수 있다. Ref 객체 참조 ref 속성은 render()메서드에서 생성된 DOM 노드나 React 요소에 접근하는 방법이다.","link":"/React/reactForm/"},{"title":"React 훅(Hook)과 접근성","text":"React Hook &amp; 접근성 React Hook1. React 클래스 컴포넌트 → 함수형 컴포넌트로 전환 (상태 관리) 상태 관리는 state를 useState를 사용해서 관리한다. useState는 React에서 import해와야한다. 123456789101112131415import React,{useState} from 'react';function App() { // 배열에 첫번째는 state 이름, 두번쨰는 setState로 값을 변경해주는 함수명 입력, useState()의 괄호 안에는 기본값을 넣어준다. const [state, setState] = useState(default); // 함수를 정의하여 작성 const functions = () &gt; { } // return 값 안에 HTML 구조 작성 return( &lt;div&gt;&lt;/div&gt; )} 2. 메서드를 활용한 사이드 이펙트 처리 useEffect()사용하기 componentDidMount와 componentDidUpdate등을 한번에 처리해주는 부분 123456789101112131415161718192021222324252627let bool = true;function component(props) { useEffect(() =&gt; { if(bool) { // componentDidMount } // componentDidUpdate return () =&gt; { // componentWillUnmount } }) // 특정 props만 관리하고 싶을 경우 useEffect(() =&gt; { if(bool) { // componentDidMount } // componentDidUpdate return () =&gt; { // componentWillUnmount } }, [ // 관리하고 싶은 props ])} 3. 메서드를 활용한 DOM 노드 접근/조작 useRef useRef()는 실제 DOM노드를 참조 할 경우 사용하며, 참조 대항의 변경이 필요한 경우 .current속성을 사용한다. useRef()는 컴포넌트가 다시 그려지지 않는 점에 주의해야한다. 이때는 useCallback()훅을 사용하여 컴포넌트 state를 업데이트하여 컴포넌트를 다시 그리게 해주어야한다. 다음과 같은 방식으로 사용 12345678910111213141516171819202122function Image() { const [image, setImage] = useState({ src: '', alt: '' }); const image = useRef(null); const changeImage = (path) =&gt; { setImage({ src: path, alr: '설명' }) } return( &lt;div&gt; &lt;img src={image.src}&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; changeImagePath('pathName')}&gt;이미지 변경&lt;/button&gt; &lt;/div&gt; )} 4. 메서드를 활용한 컨텍스트 데이터 공유 useContext useContext() 훅은 클래스 컴포넌트의 static contextType 또는 &lt;Context.Consumer&gt;와 동일하며, 컨텍스트를 읽고, 변경사항을 구독하는 것만 가능하다. 컨텍스트의 값을 변경하려면 &lt;Context.Provider&gt;가 필요하다. 기존에 고차 컨텍스트인 static Context, contextType 사용하지 않고 간단하게 사용 가능하다. 접근성React-axe 패키지 모듈을 활용한 접근성 자동 검사 React-axe란 axe-core 테스트 도구를 래핑한 React-axe라이버러리는 React 엡의 모든 페이지 접근성을 자동으로 검사하여 개발자에게 실시간 피드백을 전달한다. 피드백을 확인하고 문제를 해결함으로 잠재적인 접근성 문제를 미연에 방지할 수 있다. npm i react-axe -D를 사용하여 react-axe를 설치하여 준다. index.js에서 사용하여야 주어야 한다. 1234if (process.env.NODE_ENV !== 'production') { // axe는 1번째인자로 React, 2번째는 ReactDOM, 3번째는 앱 실행 후 몇초뒤에 실행할지 설정값을 넣어준다. 밑에서는 1초로 설정하였다. axe(React, ReactDOM, 1000);} 개발상태에서만 axe를 사용해준다. 만약 오류 발생신 console창에서 axe오류(접근성에 대한 오류)를 발생 시켜준다. axe-core 확인 시 오류를 한국어로 표시할 수 있게 바꿔줄수 있다. 이때 src 폴더 안에 axe-locale이라는 폴더를 생성 후에 index.js파일에서 import해주면 한글로 바꿔서 오류를 표시해줄 수 있다. axe-core를 설치한 후 ko.json 파일을 생성 후 axe-locale-ko.js 파일 생성 후 다음과 같이 생성해준다.1234import axeCore from 'axe-core';import ko from './ko.json';axeCore.configure({ locale: ko });","link":"/React/reactHook/"},{"title":"React 팁","text":"React 팁 1. 절대경로 임포트 (jsconfig.json 설정) 절대 경로로 바꾸는 법 jsconfig.json 파일에 다음 코드 추가 123456{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;src&quot;}, &quot;include&quot;: [&quot;src&quot;]} 설정 후에는 상대 경로 대신 아래와 같은 절대 경로를 사용하여 컴포넌트 불러오기 src 안에 있는 파일을 ./과 ../ 없이도 찾아 올수 있다. 2. ReactComponent를 활용한 SVG 이미지 스타일링 &amp; 애니메이션 SVG 파일을 React 프로젝트에서 사용할 경우, 아래 예시 코드처럼 이미지 경로를 가져와 &lt;img/&gt;요소의 src 속성 값으로 사용해 이미지를 그려내야한다.12345// 이미지 경로 처리import logo from './assets/logo.svg';// img 요소의 src 값으로 처리const reactLogo = &lt;img src={logo} alt=&quot;React 로고&quot; /&gt;; img 요소로 호출된 SVG 그래픽은 여러 제약이 있다. 위의 제약 때문에 ReactComponent를 사용하여 SVG를 불러오는 것이 style과 애니메이션 사용에 더 용이하다. 3. Sass를 활용한 스타일 모듈화 css 프리포로세서인 Sass를 Create-React-App으로 새성한 프로젝트에서 사용하려면 node-sass 모듈을 설치해야한다. 설치 순서 npm i node-sass를 사용해서 설치 파일명.scss와 같은 형식으로 사용 4. CSS 모듈을 사용해 고유한 클래스 이름 생성(스타일 충돌 방지) css 모듈 똑같은 css명을 사용할때 충돌을 방지하기 위해 고유성을 지키기 위해 css 모듈을 사용한다. 5. craco를 활용해 설정 덮어쓰기 (Sass 소스맵 설정) craco 사용 이유 CRA를 사용해 제작한 프로젝트 설정을 변경하려면 eject명령을 사용해야 하고, 한번 eject하면 되돌릴 수 없다. 위의 불편을 감수하는 대신 Craco를 사용하여 꺼내기를 하지 않고도 CRA 설정을 덮어 쓸 수 있다. craco 사용 방법 npm i craco를 사용하여 설치 craco.config.js 파일을 프로젝트 루트에 생성123module.exports = ({env}) =&gt; { return {}} package.json파일에 scripts 부분을 eject를 제외한 나머비 부분을 ‘react-scripts’ -&gt; ‘craco’로 변경해준다. 생성해 놓았던 craco.config.js파일에 sourceMap 옵션이 정상적으로 작용하도록 설정1234567const sassSourcemapsPlugin = require('./config/plugins/craco-sass-sourcemap');module.exports = { pulgins: [ { plugin : sassSourcemapsPlugin } ] } ./config/plugins/craco-sass-sourcemap 해당 루트에 파일 생성12345678910111213141516171819202122232425262728293031323334353637module.exports = { overrideWeppackConfig : ({ webpackConfig, cracoConfig, pluginOptions, context: { env, paths } }) =&gt; { function traverse(obj, callback) { if (Array.isArray(obj)) { obj.forEach((item) =&gt; traverse(item, callback)) } else if (typeof obj === 'object' &amp;&amp; obj !== null) { Object.keys(obj).forEach((key) =&gt; { if (obj.hasOwnProperty(key)) { callback(obj, key); traverse(obj[key], callback); } }) } } traverse(weppackConfig, (node, key) =&gt; { if(key === 'loader') { if( node[key].indexOf('sass-loader') !== -1 || node[key].indexOf('postcss-loader') !== -1 || node[key].indexOf('css-loader') !== -1 ) { if(node.options) { node.options.sourceMap = true; } } } }); return webpackConfig; },} 각 scss 파일의 코드를 sources에서 명시적으로 볼 수 있다. 자세한 설명 6. classNames() 유틸리티 활용 classNames() 사용 이유 React에서 css 클래스 속성을 사용 시 동작 또는 조건 처리하여 결합하는 JS유틸리티 함수이다. 자세한 설명 사용 방법 npm i classnames사용하여 설치 코드에서 다음과 같이 사용한다.12345678910111213141516171819202122232425262728293031 // scss 파일 불러오기 import styles from 'styles.scss'; import classNames from 'classnames/bind'; let cx = classNames.bind(styles); ``` ## 7. React 컴포넌트 / 유닛 테스트 디버깅- React 컴포넌트 디버깅 - VSCode에서 [Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome)을 설치하여 React 컴포넌트를 디버깅한다. - 설치가 완료되면 디버깅패널을 열어 chrome 실행 스크립트를 구성해주어야 한다. ```json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Debug CRA&quot;, &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;${workspaceRoot}/src&quot;, &quot;sourceMapPathOverrides&quot;: { &quot;webpack:///src/*&quot;: &quot;${webRoot}/*&quot; } } ] } 설정 후에 npm run start을 헤준 후 debug해주고 싶은 부분에 점을 찍어 실행해준다. 유닛 테스트용 실행 스크립트 구성 VSCode에디터의 디버그 패널을 연 후, 실행 스크립트 구성을 추가해준다. 다음 코드를 configurations 배열 안에 넣어준다.1234567891011121314151617181920{ &quot;name&quot;: &quot;Debug CRA Tests&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;runtimeExecutable&quot;: &quot;${workspaceRoot}/node_modules/.bin/react-scripts&quot;, &quot;args&quot;: [ &quot;tests&quot;, &quot;--runInBand&quot;, &quot;--no-cache&quot;, &quot;--watchAll=false&quot; ], &quot;cwd&quot;: &quot;${workspaceRoot}&quot;, &quot;protocol&quot;: &quot;inspector&quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;env&quot;: { &quot;CI&quot;: &quot;true&quot; }, &quot;disableOptimisticBPs&quot;: true} 파일명.test.js 파일을 생성해준다. 이때 test 파일 안에는 index.js와 비슷하다. 1234567891011121314151617181920212223242526272829import React from 'react';import ReactDOM from 'react-dom';import Lecturers from './Lecturers'; // 검수할 파일import { FEML_lectures as lectures } from 'App'; // 필요한 데이터// 가상DOM을 실제DOM으로 패치헤서 확인하기 위해 변수 생성 let tester;// test 전에 div 생성후 tester에 참조 시켜준다.beforeEach(() =&gt; { tester = document.createElement('div');})// test 완료 후에 tester 삭제afterEach(() =&gt; { ReactDOM.unmountComponentAtNode(tester);})// 전달된 props를 받아 lecturers를 render를 해준다.const render = (props) =&gt; { ReactDOM.render(&lt;Lecturers instructor={props.lecturers} /&gt;, tester)}it('Front-End Masters League 강사진 중 첫번째 강사의 이름', () =&gt; { render({ lecturers }); const firstLecturerLink = tester.querySelector('.lecturer a'); const href = firstLecturerLink.getAttribute('href); expect(href).toEqual('https//facebook.com'); })","link":"/React/reactTip/"},{"title":"React JSX","text":"React JSX 1. React 요소를 만드는 2가지 방법 JSX란 =&gt; React 요소 JSX(JavaScript Syntax eXtension)는 HTML과 유사한 문법을 사용해 React요소(JavaScript 객체)를 만들 수 있도록 한다. JavaScript UI view를 구성하는 마크업하는 것은 매우 까다로워 특별한 경우가 아니라면 JSX사용 권장 JSX가 하는 일은 React 요소(Element)를 만드는 것이다. React.createElement()를 사용해 UI view를 구성하는 것을 보다 쉽고 간단한 점이 장점이다. JSX와 React.createElement() 사용하는 방법 JSX가 훨씬 보기 편하고 간단하게 작성 가능 및 가독성이 더 높다.(HTML과 유사) 12345678910// JSXconst app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// ReactElement.createElement()const appHeading = React.createElement('h1', {class: 'app-title'}, 'React.createElement() 메서드')const appElement = React.createElement('div', {class: 'app'}, appHeading) 2. 가상 DOM이란? 실제 DOM에 직접적으로 조작하는 것이 아니라, 이전/이후 상태를 비교하여 변경 사항이 발생할 때 변경된 부분만 실제 DOM에 업데이트(patch)하므로 UI 속도를 향상시킬 수 있다. ReactDom모듈은 React요소로 구성된 가상 DOM을 실제 DOM에 Mount시켜 렌더링해주는 역할을 수행한다. ReactDom.render(container, document.getElementById('root')) 실제 DOM을 사용하는 대표적인 것은 JQuery 가상 DOM을 사용하는 것은 React, View 등 가상 DOM 사용 이유 UI는 사용자의 요구사항에 따라 수시로 변경(업데이트)된다. 업데이트 과정에서 실제 DOM이 변경되면 업데이트 된 요소와 그 자식 요소를 다시 렌더링 해야하는데, 이러한 과정이 UI 속도를 늦춘다. UI 컴포넌트 개수가 많을 수록 렌더링 비용은 더욱 많이 들어 속도는 더더욱 느려지게 된다.(렌더링 비용 UP, 속도 DOWN) 3. JSX 코드가 Babel 컴파일러를 만나면? Babel's Compile JSX를 React.createElement()를 사용해 컴파일한다. 123456789101112131415// JSX 코드const app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// Babel 다음과 같이 컴파일을 함 (React 요소) 가상 DOM을 구성하고 필요에 따라 실제 DOM을 업데이트 한다.const iframeWrapper = React.createElement( // .iframe-wrapper 'div', { className: 'wrapper' }, // .wrapper &gt; h1 React.createElement('h1', {className: 'header'}) // ...으로 속에 코드들을 늘어남) 4. JSX 활용데이터 바인딩이란? JSX란 JavaScript 표현식을 중괄호({})로 묶어 데이터를 바인딩한다. HTML 코드에서 데이터를 빼내 변수에 등록한 후, 변수를 HTML 코드에 바인딩할 수 있다. 이때 데이터는 state 영역의 변수 코드이다. 콘텐츠 바인딩과 JavaScript 표현식 JavaScript 식(Expression)은 항상 값을 반환하므로 {} 안에 바인딩이 가능하다. 중괄호 안에는 문 대신 식을 사용해야한다. 속성 바인딩 (style, className) state나 props로 속성을 변수에 담아 선언해준다. app 중괄호 안에 속성으로 들어가는 값을 넣어주어야 한다. 대표적으로 style 속성등을 넣어주는데 사용한다. 조건 문을 사용한 조건부 렌더링 (if, switch 문) 함수를 생성하여 조건문을 사용해서 처리 후 함수를 렌더링 해주어야 한다. 조건 식을 사용한 사용한 조건부 렌더링 (3항식, 논리연산자) 위의 조건문 보다는 조건식은 바인딩 부분에 바로 사용이 가능하다. 조건 식은 속성 바인딩에도 사용이 가능하다. Array 객체의 map() 메서드를 활용한 리스트 렌더링 state나 props에 배열로 저장되어있는 값을 렌더링 부분에서 .map()매서드를 사용하여 배열을 풀어서 사용할 수 있다. JSX 사용시 주의할 점 속성이름은 CamelCase로 표기 JSX는 HTML이 아니라 JavaScript 식이므로 React DOM은 HTML 표준 속성이름 중 일부는 그대로 사용할 수 없다. 예를 들어 class -&gt; className tabindex -&gt; tabIndex 접근성 속성은 하이픈케이스 사용 예를 들어 aria-label 과 같은 접근성 속성은 하이픈케이스를 사용한다. 컨텐츠가 없는 요소는 항상 닫아야한다. JSX는 XML 문법에 따라 콘텐츠가 없는 빈 요소는 반드시 닫아야한다. 예를들어 &lt;img/&gt; &lt;br/&gt; &lt;area/&gt; 등 루트 요소가 무조건 하나여야 한다. 만약 div로 무의미하게 감싸는 것 보다는 React.Fragment를 사용하는 것이 효율적이다.","link":"/React/reactJSX/"},{"title":"React Base","text":"React란?React는 UI를 구현하는 JavaScript 라이브러리로 현 시점에서 전 세계적으로 가장 사용율이 높으며, 웹 앱, 네이티브 모바일 앱(Android, iOS 등) 개발 등 다양한 플랫폼에서 애플리케이션을 제작하는 공통된 핵심 개발 방법을 제공합니다. React는 컴포넌트 기반 프로그래밍 - 캡슐화 된 컴포넌트 로직은 템플릿이 아닌 JSX(JavaScript+XML)로 사용가능하다. React 시작하기React 러닝 다이어그램1. 공부해야 할 것들 ES6+ 가상 DOM 컴포넌트화(내부 JSX) 웹 접근성 함수 컴포넌트 2. React 컴포넌트와 요소컴포넌트 요소 React Component는 설계이다. 설계를 사용해서 인스턴스를 만들어 내는데 이때 component는 객체를 반환해주는데 이때 app이라는 변수에 담아 rendering을 시키면 실제 dom요소에서 해당 아이디를 찾아 화면에 보여주게 된다. 12345678910// React Component (Functional)function App() { return &lt;div&gt;React Element&lt;/div&gt; }// React element(JSX)var app = &lt;App/&gt;// ReactDom - renderingReactDOM.render(app, document.querySelector('#app')); 3. React 컴포넌트 구조 이해 및 활용네이티브 컴포넌트 vs 커스텀 컴포넌트 네이티브 컴포넌트를 커스텀 컴포넌트화 하여 중복되는 구조의 함수로 만들어 커스텀하는 요소를 말한다. 이때 react에서는 class를 사용할수 없고 className으로 사용해서 요소에 class를 넣어주어야 한다. React 요소 원하는 함수형 component를 생성하여 html요소처럼 사용이 가능하다. 4. React 프로젝트 생성 with CRA(Create React App) React 프레임 워크 사용해 개발, 배포시에 워크 플로우 개발 단계 npm : 모듈관리 모던 자바스크립트 : ES6 컴포넌트 시스템 : React 개발 서버 : Node.js 애플리케이션 개발 배포 단계 webpack : 번들링, 브라우저 호환성, 최적화 위와 같은 것을 CRA(Create React App)에서 처리해준다. npx create-react-app &lt;프로젝트-이름&gt;을 사용하여 CRA를 사용한 폴더를 생성해준다. 위의 코드 실행시 다음과 같이 폴더가 생성이 된다. 5. React 프로젝트 디렉토리 구조 구조12345678910111213141516- README.md- node_modules/ -&gt; 개발 의존 모듈 집합 디렉토리- package.json- public/ -&gt; 정적 리소스 디렉토리 - favicon.ico - index.html -&gt; 애플리케이션 기본 템플릿 - manifest.json- src/ -&gt; React 애플리케이션 개발 디텍토리 - App.css - App.js -&gt; 애플리케이션 파일 - App.test.js - index.css - index.js -&gt; 엔트리 파일 - logo.svg - serviceWorker.js- yarn.lock public/index.html React 앱이 구성되는 기본 템플릿 파일이다. src/index.js 애플리케이션의 엔트리 파일로 애플리케이션을 구성하는 설정이 포함되어 있다. React : React 모듈 로드 React-dom : React-dom 모듈 로드 렌더함수를 사용해 src/index.html 요소를 내부에 동적으로 App 컴포넌트를 랜더링한다. src/App.js 실질적인 React 앱에 대한 요소 함수형 컴포넌트를 export default로 내보낸다.","link":"/React/reactbase/"},{"title":"개인 프로젝트 모음","text":"React 공부 순서 React 기초 React Props와 State React JSX React 이벤트 핸들러와 컴포넌트 통신 React Context &amp; 고차 컴포넌트 React 폼 컨트롤러 React 훅(Hook)과 접근성","link":"/PersonalProject/index/"},{"title":"리액트 면접 질문","text":"React 면접 질문 1. React Life-Cycle 다음과 같은 방식으로 React Life-Cycle로 진행됩니다. Life-Cycle API란?컴포넌트가 브라우저에서 나타날때, 사라질때, 업데이트 될 때 호출되는 API입니다. 2. React State 관리 State를 올바르게 사용하는 방법 직접 state를 수정하지 마세요. 값을 직접 수정하는 것이 state를 변경하는 것이 아니라 setState()를 사용하여 값을 변경해주어야 합니다. 12345// Wrongthis.state.value = '새로운 값';// Correctthis.setState({ value: '새로운 값' }); State 업데이트는 비동기적일 수도 있습니다. React는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리할 수 있습니다.","link":"/Interview/ReactInterview/"},{"title":"React-Redux 기초","text":"Redux Redux란? React에서는 React 컴포넌트에서 각자 상태(state)를 관리하는데 Redux를 사용하게 되면 State를 별도의 Store에서 State 관리하고 React Component에서는 해당 state를 보여주기만 한다. 1. Redux가 필요한 이유 상태 관리의 필요성 애플리케이션 상태 관리는 버그를 최소화하면서 잘 만들어진 경험(UX)을 사용자에게 제공하는 데 절대적으로 중요하다. 애플리케이션의 상태를 관리하기 위한 견고하고 안정적인 솔루션을 제공한다. 혼란스럼게 흩어져 있는 상태를 체계화 하여 애플리케이션을 관리하도록 도와준다. React의 경우 컴포넌트 간의 데이터 관리를 props를 사용하여 부모에서 자식으로 넘겨주어 관리하는데 이렇게 관리를 하게 되면 복잡하게 되는데 Redux는 이러한 상태관리를 독립된 Store(저장소)를 생성하여 상태를 관리하게 됩니다. redux의 장점 예측 가능하다. 중앙에서 체계적으로 관리가능하다. debug가 쉽다. 유연하게 다른 라이브러리, 프레임워크와 사용이 가능하다. 2. Redux의 작동 흐름 (3원칙) 애플리케이션 상태는 모두 한 곳에서 집중 관리된다.(동기화 필요 없음) 상태는 불변 데이터 이며, 오직 액션 만이 상태 교체를 요청할 수 있다. (예측 가능) Reducer(리듀서 함수)를 통해 상태의 최종 값만 설정한다.(단순환) App에서 상태를 교체해야할 경우 Action을 요청하고 Action은 Reducer 함수에게 상태 변경을 요청한다. Reducer에서 상태 변경이 이루어진 후 Store에 저장을 한 후 Store에 저장된 데이터를 App에 다시 전달한다. 특징으로 App에서 Action으로 요청하기 떄문에 예측이 가능하고 App상태 변화의 흐름에 디버깅이 쉽다는 점이다. 3. Redux의 아키텍처 (설계 구성 방식) Redux 구조 Store(저장소) : 애플리케이션 상태 관리 State(상태) Action(액션) : 미리 정의된 정보 패키지 전달된 정보 선택 포함 Reducer(리듀서 함수) : 액션 수신/상태 업데이트, 하나 이상 리듀서 결합 가능 Subscription(서브 스크립션) : 업데이트 된 상태를 애플리케이션에 전달 Component(뷰) : 앱 상태를 조작(사용자) store에 연결된 모든 컴포넌트(뷰)는 상태에 따라서 좌우된다. 컴포넌트(뷰)가 상태를 변경하려 할때는 Action으로 상태 변경 요청을 해야한다. Action은 Reducer함수에 요청을 하여 상태 변경을 해주고 Reducer를 통해 Store의 state를 변경시켜준다. 4. 스토어란 App의 상태를 나타내는 많은 key:value 쌍으로 구성된 정보를 가진 하나의 큰 JS객체이다. Redux 스토어는 애플리케이션의 상태를 관리하고, .getState()(상태를 가져올 때 사용),.dispatch()(Action 호출할 때 사용),.subscribe()(상태 변경을 구독할 때 사용)같은 메서드를 제공한다. 스토어 객체 생성 — Redux.createStore() 메서드1234567import { createStore } from 'redux';// Redux 스토어 생성// 리듀서 함수를 전달 받음const reudcer = (state, action) =&gt; {};const store = createStore(reducer); 다음과 같이 conosle.log(store)를 하였을때 함수 안에 getState(), dispatch(), subscribe(), replaceReducer()를 포함하는 객처를 생성하여 준다. 5. 상태(state)란 Redux Store에서 관리하는 상태(데이터) 입니다. 일반적으로 State 또는 initState 이름으로 설정한다. 상태는 Reducer의 첫번째 인자로 전달된다. 상태 트리는 불변 상태 즉 순수한 상태를 가져야한다. 레이어 상태는 리듀서로 처리 될 때 예측 가능하기 떄문이다. 상태 관리는 불변 데이터 관리를 참고해야한다. 상태(state) 가져오기 — store.getState() 메서드 store를 등록 후에 .getState()를 사용하여 등록된 상태 정보를 가져올 수 있다. 1234567891011import { createStore } from 'redux';const initialData = 'Redux State Data';const reudcer = (state, action) =&gt; { return state;};// 이때 Reducer는 함수를 return해주어야 하기 떄문에 다음과 같이 사용해주어야 한다.const store = createStore(() =&gt; reducer(initialData));console.log(store.getState()); 6. 액션(action)이란? 액션은 App에서 “상태 변경을 설명하는 정보”를 스토어로 보내는 JS객체로 Redux에 알려 변화를 이끌어낸다. 상태 값을 변경(교체)할 경우, 교체 할 상태 값을 리듀서(함수)에 보낼 수 있다. 액션(action) — type, payload 속성을 가진 객체 type은 대문자로 작성해주는 것이 관례이다. 123const increaseCountAction = { type: 'INCREASE_COUNT' };const decreaseCountAction = { type: 'DECREASE_COUNT' };const resetCountAction = { type: 'RESET_COUNT', payload: 0 }; 실제 사용 방법 다음과 같이 사용할 때 Action을 통해 type을 정의해주고 Type에 따라 state(상태)를 변경시켜 줄 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243import { createStore } from 'redux';const initialData = 'Redux State Data';// 정적으로 처리하는 방법const changeDataAction = { type: 'CHANGE_DATA',};// 동적으로 처리하는 방법const changeAnotherDataAction = { type: 'CHANGE_Another_DATA', payload: 'change_payload Data',};const reudcer = (state = initialData, action) =&gt; { console.log(action); switch (action.type) { case 'CHANGE_DATA': state = 'Redux Change State Data'; breake; case 'CHANGE_Another_DATA': state = action.payload; breake; } return state;};const store = createStore(initialData);// 이때 출력값은 initailData가 된다.console.log(store.getState());// setTimeOut을 통해 reducer안에 Action의 type에 대해 알아본다.widow.setTimeout(() =&gt; { store.dispatch(changeDataAction);}, 3000);widow.setTimeout(() =&gt; { store.dispatch(changeAnotherDataAction);}, 5000); 액션 타입을 별도로 관리 액션 타입을 별도로 관리하는 파일을 만들어 상수로 관리하는 것이 유지보수 하기 좋다. 12345// store/action/actionTypes.jsexport const INCREASE_COUNT = 'INCREASE_COUNT';export const DECREASE_COUNT = 'DECREASE_COUNT';export const RESET_COUNT = 'RESET_COUNT'; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { createStore } from 'redux';const initialData = 'Redux State Data';// actionType.jsconst CHANGE_DATA = 'CHANGE_DATA';const CHANGE_Another_DATA = 'CHANGE_Another_DATA';// action.js// 정적으로 처리하는 방법const changeDataAction = { type: CHANGE_DATA,};// 동적으로 처리하는 방법const changeAnotherDataAction = { type: CHANGE_Another_DATA, payload: 'change_payload Data',};const reudcer = (state = initialData, action) =&gt; { console.log(action); switch (action.type) { case CHANGE_DATA: state = 'Redux Change State Data'; breake; case CHANGE_Another_DATA: state = action.payload; breake; } return state;};const store = createStore(initialData);// 이때 출력값은 initailData가 된다.console.log(store.getState());// setTimeOut을 통해 reducer안에 Action의 type에 대해 알아본다.widow.setTimeout(() =&gt; { store.dispatch(changeDataAction);}, 3000);widow.setTimeout(() =&gt; { store.dispatch(changeAnotherDataAction);}, 5000); 7. 리듀서(reducer) — 순수한 함수 모든 Redux App은 Reducer(리듀서)를 구현해야한다는 공통점이 있다. 애플리케이션 상태를 교체하는 함수를 말한다. 이전 상태(prevState)를 새로운 상태(state)로 교체한다. 12345리듀서 = (상태, 액션) { // 액션 타입 분석 // 이전 상태 -&gt; 다음 상태로 교체 // 다음 상태 변환} Reducer 특성 전달 받은 매개변수 state, action에 변형을 가하면 안된다. 네트워킹(API호출 &lt;- 비동기 통신) 또는 라우팅을 변경하면 안된다. 반드시 반환 값은 새로운 상태이어야 한다. 순수한 함수란? 순수 함수는 반환 값이 전달 인자 값에만 의존하는 함수를 말한다. 순수 함수는 새로운 값을 계산한다. 동일한 유형의 인자 집합을 사용해 순수 함수를 호출하면 예측 가능한 결과 값을 확신할 수 있다. 순수 함수는 전달 된 인자 값을 변경하지 않는다. 다음과 같은 함수를 순수한 함수라고 한다. 12const square = x =&gt; x * x;const sqareAll = items =&gt; items.map(square); 순수하지 못한 함수는 DB 또는 네트워크 통신 및 DOM 조작과 같은 경우를 말한다. 1234567const square = x =&gt; { updateXInDatabase(x); return x * x;};const sqareAll = items =&gt; { items.forEach(item =&gt; (item = square(item)));};","link":"/Redux/index/"},{"title":"React-Redux 설명","text":"React-Redux란? 1. React 앱 + Redux APP.js에서 꼭 렌더링한 App을 subscribe()를 해주어야 Redux를 구동할 수 있다. React + Redux — 루트 리듀서 (여러 개의 리듀서 병합) Redux의 스토어는 하나이지만, Reducer는 하나 이상 생성할 수 있다. APP의 규모가 커지면 그 만큼 Reducer가 많아지게 된다. 이에 따라 멀티 Reducer를 관리하려면 하나의 루트 리듀서를 만들어 다수의 Reducer를 변합하여 사용한다. 루트 리듀서는 conbineReducers()함수를 사용해 다수의 리듀서를 묶어서 관리할 수 있었다. 1234567import { combineReducers } from 'redux';import todosReducer from './reducers/todosReducer';import counterReducer from './reducers/counterReducer';const rootReducer = combineReducers({ todosReducer, counterReducer });export default rootReducer; 2. React Redux react-redux 패키지는 React에 맞게 Redux를 사용할 수 있도록 한다. React-Redux - 설치해당 코드를 사용하여 React-Redux 설치하여야 한다. 1npm i react-redux React-Redux - Provider, Connect 컴포넌트 Provider와 Connect는 React앱에 Redux의 효율적은 App 상태 관리 방법을 쉽게 사용할 수 있도록 관계를 형성해야한다. 다음 사진과 같은 방식으로 React-Redux에 관한 작동 흐름이다. Counter App은 React에서 가상 DOM으로 구성되어있다. ReactDom.render에서 실제 DOM에 뿌려주게 된다. Store에 있는 데이터를 모든 DOM에 뿌려주기 위해 Provider 즉 공급자로 각 DOM에 공급하게 됩니다. Provider를 감싼 하위 컴포넌트에 Store를 공급할 수 있고 Connect를 사용하여 Store에 상태를 업데이트하기 위해 Connect에서는 상태 업데이트하기 위해 dispatch를 사용하여 업데이트하고 Action은 Reducer를 실행하기 위하여 보내는 역할을 한다. Provider Provider는 포함된 모든 하위(자식, 자손) 컴포넌트에 Redux Store를 제공하는 컴포넌트이다. &lt;provider&gt;로 &lt;App/&gt;을 감싸게 되면 모든 컴폰너트에서 스토어에 접근해 상태 변경을 요청(dispatch)하거나, 구독(subscription)된 상태가 업데이트 되면 다시 렌더링 된다. 123456ReactDom.render( &lt;provider store={stpre}&gt; &lt;App /&gt; &lt;/provider&gt;, document.getElementById('root')); Connect Connect는 컴포넌트를 스토어에 접근 가능하도록 연결하는 컴포넌트 이다. Connect를 사용하면 컴포넌트에 일일이 Store 또는 상태(state), 디스패치(dispatch)를 직접 연결하지 않아도 된다. Connect컴포넌트는 고차 컴포넌트(HOC)입니다. HOC가 하는 일은 기존 컴포넌트를 랩핑하고 추가 기능을 주입해 기준 컴포넌트의 기능을 확장한다. 12345678910111213import { connect } from 'react-redux';const Component = () =&gt; { const { stateName } = this.props; return ();};// 다음과 같이 Reducer를 통해 Store에 있는 state를 변수로 가져올 수 있다.const mapStateToProps = state =&gt; ({ stateName: state.stateReducer.stateName,});// 다음과 같이 Component를 connect로 감싸주어 사용가능export default connect(mapStateToProps)(Component); React Redux 패키지 — Connect 고차 컴포넌트의 mapStateToProps, mapDispatchToProps 설정 좀더 자세한 설명 Redux Devtools — 상태 관리 시각화 Redux DevTools 설치 사이트 로 이동하여 다운로드 해주면 됩니다. Chrome 검사창을 열어 Redux를 열어주면 Redux 변동사항 및 데이터가 넘어가는것을 시각화로 볼 수 있다. 3. React Redux Hooks 다음과 같이 useSelector와 useDispatch를 사용할 수 있다.import { useSelector, useDispatch } from &quot;react-redux&quot;; React-Redux: UseSelector() 이 Hook은 리덕스 스토어의 상태에 접근할 수 있다.const result: any = useSelector(selector: Function, equalityFn ?: Function) 여기서 두번째 파라미터로 오는 equalityFun은 이전값과 다음값을 비교하여 true이면 랜더링하지 않고, false이면 리랜더한다. -UseSelectir() 최적화 방법 3가지 해당 사이트를 참고해주세요. React-Redux: UseDispatch() 이 훅은 기존에 props로 액션 생성 함수를 사용하는 것처럼 액션 객체를 dispatch해준다.const dispatch = useDispatch();","link":"/Redux/reactRedux/"},{"title":"React-Redux 모듈 관리 및 Reducer 예제","text":"Redux 모듈 관리 및 Redux 예제, UnitTest 1. Redux 스토어 모듈 관리 Redux 스토어 구조 123456789store/ // 스토어 엔트리 (스토어 생성) index.js actions/ index.js // 액션 엔트리 (Action 내보내기) actionTypes.js // 액션 타입 reducers/ index.js // 리듀서 엔트리 #상태 업데이트 구독과 취소 — store.subscribe() 메서드 서브스크립션이란 APP 상태 변경을 구독(subscribe, 감지)하여 상태가 업데이트 되면 등록된 리스너를 실행시킨다. click()이벤트와 같이 상태가 업데이트 될 때 구독을 하면 상태가 업데이트 될때 어떤 부분이 업데이트 되는지 알수 있다. React-Redux 라이브러리를\u001c사용하면 서브스크립션은 자동 처리된다. 2. Reducer(리듀서) 함수 리듀서는 액션을 전달 받아 상태를 교체하는 순수 함수이다. TodoReducer 함수 — 작성 Rdeucer 생성 시 store/reducers파일 내에 reducer에 해당하는 todosReducer.js파일을 생성 후 작성을 해준다. 12345678910111213141516171819202122232425262728293031323334353637import { ADD_TODO, REMOVE_TODO, RESET_TODO, REPLACE_TODO,} from '../actions/actionTypes';export const initialState = [ 'Redux 라이브러리 설치', 'Redux 아케텍처 이해',];export const todosReducer = (state = initialState, { type, todo }) =&gt; { switch (type) { case ADD_TODO: state = [...state, todo]; break; case REMOVE_TODO: state = state.filter(item =&gt; item !== todo); break; case RESET_TODO: state = initailState; break; case REPLACE_TODO: if (item === todo.item) { //todo = {item,replaceItem} return todo.replaceItem; } return item; break; default: console.log( '일치하는 액션 타입이 존재하지 않습니다. 확인 후 다시 시도해주세요' ); } return state;}; store/actions/actionTypes.js파일 내에 123456export const CHANGE_DATA = 'CHANGE_DATA';export const ADD_TODO = 'ADD_TODO';export const REMOVE_TODO = 'REMOVE_TODO';export const RESET_TODO = 'RESET_TODO';export const REPLACE_TODO = 'REPLACE_TODO'; TodoReducer 함수 — 유닛 테스트 Reducer Unit test 코드 짜는 법 다음과 같이 요청 하나하나에 대한 요청에 테스트를 해주어야한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import { ADD_TODO, REMOVE_TODO, RESET_TODO, REPLACE_TODO,} from '../actions/actionTypes';import { initialState, todosReducer } from './todosReducer';// Unit Testit('todosReducer 함수의 ADD_TODO 액션은 올바르게 작동하는가?', () =&gt; { const addTodoTestValue = '액션과 액션 타입 활용'; const addTodoTest = todosReducer(todos, { type: ADD_TODO, todo: addTodoTestValue, }); expect(todoTest).toEqual([...todos, addTodoTestValue]);});it('todosReducer 함수의 REMOVE_TODO 액션은 올바르게 작동하는가?', () =&gt; { const removeTodoTestValue = '액션과 액션 타입 활용'; const removeTodoTest = todosReducer(todos, { type: REMOVE_TODO, todo: removeTodoTestValue, }); expect(removeTodoTest).toEqual( todos.filter(todo =&gt; todo !== removeTodoTestValue) );});it('todosReducer 함수의 RESET_TODO 액션은 올바르게 작동하는가?', () =&gt; { const resetTodoTest = todosReducer(todos, { type: RESET_TODO, }); expect(resetTodoTest).toEqual(todos);});it('todosReducer 함수의 REPLACE_TODO 액션은 올바르게 작동하는가?', () =&gt; { const replaceTodoTestValue = { item: '액션과 액션 타입 활용', replaceItem: 'React Redux 활용', }; const replaceTodoTest = todosReducer(todos, { type: REPLACE_TODO, todo: replaceTodoTestValue, }); expect(replaceTodoTest).toEqual([ '액션과 액션 타입 활용', 'React Redux 활용', ]);}); 3. Redux 패턴 리뷰 .createStore(reducer) : 스토어 생성(reducer) store.getState() : 스토어 상태 반환 store.dispatch(action) : 스토어 상태 변경 전달(액션) store.subscribe(listener) : 스토어 상태 반경 감지(리스너) .createStore(reducer) 작동원리 .createStore(reducer)은 다음과 같이 작동합니다. 다음과 같은 createStore()함수를 봤을 때 reducer는 단지 일반적인 함수일 뿐이고 메서드로 state와 action을 받아 사용한다. dispatch메서드는 reducer힘수에서 전달 받은 state와 action을 받아 state를 업데이트를 한다. 12345678910111213141516171819202122232425262728293031// import { createStore } from 'redux';// createStore(reducer) =&gt; store {};// store = {getState, subscribe, dispatch};const createStore = reducer =&gt; { let state; // 외부에서는 접근이 불가한 데이터 // 데이터 반환 메서드 const getState = () =&gt; state; let listenrs = []; // 등록된 리스너(함수) 보관하는 리스트(배열) // 구독(업데이트 실행 함수 연결) 메서드 const subscribe = listener =&gt; { listeners.push(listener); // 구독 취소 (업데이트 실행 함수 제거) 메서드 반환 return removeListener =&gt; { listeners = listeners.filter(listener =&gt; listener !== removeListener); }; }; // 디스패치(알림, 업데이트 요청) 메서드 const dispatch = action =&gt; { // state 업데이트 state = reducer(state, action); // listeners의 모든 listener를 실행 listeners.forEach(listener =&gt; listener()); }; return { getState, subscribe, dispatch };};","link":"/Redux/reduxModule/"}],"tags":[{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"HTML이란","slug":"HTML이란","link":"/tags/HTML%EC%9D%B4%EB%9E%80/"},{"name":"HTML 공부 순서","slug":"HTML-공부-순서","link":"/tags/HTML-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/"},{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"HEXO 블로그","slug":"HEXO-블로그","link":"/tags/HEXO-%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"Github page","slug":"Github-page","link":"/tags/Github-page/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"JS 공부 순서","slug":"JS-공부-순서","link":"/tags/JS-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/"},{"name":"Icarus 테마","slug":"Icarus-테마","link":"/tags/Icarus-%ED%85%8C%EB%A7%88/"},{"name":"JS란","slug":"JS란","link":"/tags/JS%EB%9E%80/"},{"name":"변수 선언","slug":"변수-선언","link":"/tags/%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8/"},{"name":"주석 &#x2F; 디버깅","slug":"주석-디버깅","link":"/tags/%EC%A3%BC%EC%84%9D-%EB%94%94%EB%B2%84%EA%B9%85/"},{"name":"JS Clousre","slug":"JS-Clousre","link":"/tags/JS-Clousre/"},{"name":"JS 생성자","slug":"JS-생성자","link":"/tags/JS-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"JS 프로토타입","slug":"JS-프로토타입","link":"/tags/JS-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"},{"name":"JS DOM","slug":"JS-DOM","link":"/tags/JS-DOM/"},{"name":"JS Function","slug":"JS-Function","link":"/tags/JS-Function/"},{"name":"JS 조건문","slug":"JS-조건문","link":"/tags/JS-%EC%A1%B0%EA%B1%B4%EB%AC%B8/"},{"name":"JS 3항 연산자","slug":"JS-3항-연산자","link":"/tags/JS-3%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"DOM API","slug":"DOM-API","link":"/tags/DOM-API/"},{"name":"JS Array","slug":"JS-Array","link":"/tags/JS-Array/"},{"name":"JS Loop(반복문)","slug":"JS-Loop-반복문","link":"/tags/JS-Loop-%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"name":"JS Load","slug":"JS-Load","link":"/tags/JS-Load/"},{"name":"JS DOMContentLoaded 이벤트","slug":"JS-DOMContentLoaded-이벤트","link":"/tags/JS-DOMContentLoaded-%EC%9D%B4%EB%B2%A4%ED%8A%B8/"},{"name":"JS 숫자&#x2F;수학 객체","slug":"JS-숫자-수학-객체","link":"/tags/JS-%EC%88%AB%EC%9E%90-%EC%88%98%ED%95%99-%EA%B0%9D%EC%B2%B4/"},{"name":"JS 문자 객체","slug":"JS-문자-객체","link":"/tags/JS-%EB%AC%B8%EC%9E%90-%EA%B0%9D%EC%B2%B4/"},{"name":"JS 함수 객체 속성","slug":"JS-함수-객체-속성","link":"/tags/JS-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-%EC%86%8D%EC%84%B1/"},{"name":"JS 함수 객체 메서드","slug":"JS-함수-객체-메서드","link":"/tags/JS-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"JS 배열 객체","slug":"JS-배열-객체","link":"/tags/JS-%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4/"},{"name":"JS 객체 상속","slug":"JS-객체-상속","link":"/tags/JS-%EA%B0%9D%EC%B2%B4-%EC%83%81%EC%86%8D/"},{"name":"객체 지향 프로그래밍","slug":"객체-지향-프로그래밍","link":"/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"JS Value","slug":"JS-Value","link":"/tags/JS-Value/"},{"name":"JS 영역","slug":"JS-영역","link":"/tags/JS-%EC%98%81%EC%97%AD/"},{"name":"호이스팅","slug":"호이스팅","link":"/tags/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/"},{"name":"스코프 체이닝","slug":"스코프-체이닝","link":"/tags/%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B2%B4%EC%9D%B4%EB%8B%9D/"},{"name":"JS Type","slug":"JS-Type","link":"/tags/JS-Type/"},{"name":"JS 변수 네이밍","slug":"JS-변수-네이밍","link":"/tags/JS-%EB%B3%80%EC%88%98-%EB%84%A4%EC%9D%B4%EB%B0%8D/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"리엑트 공부 순서","slug":"리엑트-공부-순서","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/"},{"name":"React Props","slug":"React-Props","link":"/tags/React-Props/"},{"name":"React State","slug":"React-State","link":"/tags/React-State/"},{"name":"리엑트 이벤트 핸들러","slug":"리엑트-이벤트-핸들러","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC/"},{"name":"리액트 컴포넌트 통신","slug":"리액트-컴포넌트-통신","link":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%86%B5%EC%8B%A0/"},{"name":"리엑트 폼","slug":"리엑트-폼","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%8F%BC/"},{"name":"리엑트 훅","slug":"리엑트-훅","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%9B%85/"},{"name":"접근성","slug":"접근성","link":"/tags/%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"리엑트 컨텍스트","slug":"리엑트-컨텍스트","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"name":"리엑트 고차 컴포넌트(HOC)","slug":"리엑트-고차-컴포넌트-HOC","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-HOC/"},{"name":"리엑트 JSX","slug":"리엑트-JSX","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-JSX/"},{"name":"React 기본","slug":"React-기본","link":"/tags/React-%EA%B8%B0%EB%B3%B8/"},{"name":"리엑트 팁","slug":"리엑트-팁","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%8C%81/"},{"name":"HTML구조","slug":"HTML구조","link":"/tags/HTML%EA%B5%AC%EC%A1%B0/"},{"name":"Element","slug":"Element","link":"/tags/Element/"},{"name":"HTML Tag","slug":"HTML-Tag","link":"/tags/HTML-Tag/"},{"name":"리엑트 면접 질문","slug":"리엑트-면접-질문","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"React-Redux","slug":"React-Redux","link":"/tags/React-Redux/"},{"name":"Redux Module","slug":"Redux-Module","link":"/tags/Redux-Module/"},{"name":"Redux 모듈 관리","slug":"Redux-모듈-관리","link":"/tags/Redux-%EB%AA%A8%EB%93%88-%EA%B4%80%EB%A6%AC/"},{"name":"Reducer 예제","slug":"Reducer-예제","link":"/tags/Reducer-%EC%98%88%EC%A0%9C/"}],"categories":[{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"HEXO","slug":"HEXO","link":"/categories/HEXO/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Interview","slug":"React/Interview","link":"/categories/React/Interview/"},{"name":"Redux","slug":"React/Redux","link":"/categories/React/Redux/"}]}