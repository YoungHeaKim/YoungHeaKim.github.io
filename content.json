{"pages":[{"title":"About","text":"Yh Blog","link":"/about/index.html"}],"posts":[{"title":"용해의 개발 블로그","text":"","link":"/hello-world/"},{"title":"React","text":"React 공부 순서 React 기초 React Props와 State React JSX React 이벤트 핸들러와 컴포넌트 통신 React Context","link":"/react/index/"},{"title":"React Props &amp; State","text":"React Props &amp; State 1. React 컴포넌트와 전달 속성(props) React 컴포넌트로 props를 전달할 수 있다. 상위 컴포넌트에서 하위 컴포넌트로 props를 넘겨주는데 이때 상위에서 데이터를 다음과 같이 전달해 준다. 1234567891011121314151617181920212223// React Componentfunction MenuListItem(props) { return &lt;li&gt; &lt;h3&gt;{props.caption}&lt;/h3&gt; &lt;/li&gt;}// 위의 컴포넌트를 아래에서 사용function MenuList() { // 다음과 같이 Props를 전달해고 위에서처럼 값을 전달 받을수 있다. return &lt;ul&gt; &lt;MenuListItem caption = &quot;props 전달 1&quot; /&gt; &lt;MenuListItem caption = &quot;props 전달 2&quot; /&gt; &lt;/ul&gt;}// 위의 컴포넌트를 아래에서 사용function App() { return &lt;main&gt; &lt;h2&gt;&lt;/h2&gt; &lt;MenuList/&gt; &lt;/main&gt;} 2. 컴포넌트 &amp; props 컴포넌트 UI를 구성하는 조각에 해당되며, 독립적으로 분리되어 재사용을 목표로 사용한다. React 앱에서 컴포넌트는 개별적인 JavaScript 파일로 분리되어 관리한다. React 함수형 컴포넌트 함수형 컴포넌트 React 컴포넌트는 개념상 JavaScript 함수와 유사하다. 컴포넌트 외부로부터 속성(props)을 전달 받아 어떻게 UI를 구성해야 할지 설정하여 React요소(JXL를 Babel이 변환 처리)로 반환된다. 문법 구문을 사용하는 컴포넌트를 React는 함수형으로 분류한다. 컴포넌트 이름은 항상 대문자로 시작하는 TitleCase문법 사용이 권징된다. (HTML 표준 요소와 구별하기 위함) React 클래스 컴포넌트 ES6부터 지원됨 vsCode에서 React pure to Class를 선택해주면 함수형 컴포넌트를 class형 컴포넌트로 나눌수 있다. 클래스 컴포넌트 vs 함수형 컴포넌트 React에서는 두 컴포넌트는 유사하다. 클래스 컴포넌트의 경우 함수형 컴포넌트에 없는 기능을 추가적으로 사용 가능하다. React 컴포넌트 import,export / props 다른 파일로 자식 컴포넌트 분리 후 export로 파일 저장 -&gt; import로 자식 컴포넌트를 부모 컴포넌트에서 불러온다. props(전달속성) 컴포넌트에서 설정된 임의의 JSX 속성(type, children 등)은 React에 의해 컴포넌트 속성(props) 객체로 전달한다. 부모 -&gt; 자식으로 데이터를 넘길 때 사용(부모에서 props로 데이터를 넘김) 컴포넌트에 전달된 속성 객체는 읽기전용이라 수정이 불가능하다. 이때 수정을 하기위해서는 props 대신 state를 활용해야한다. React 컴포넌트 관리 (추출) 컴포넌트 트리 최상위 부모에는 App파일이 되어야하고 그안에 여러 컴포넌트를 나눠 중복 또는 반복되는 부분을 바꾸어 주어야한다. 컴포넌트 추출 컴포넌트 내부에서 컴포넌트로 사용할 수 있는 것이 보인다면 분리하는 것이 좋다. 복잡한 컴포넌트 내부에서 세분화하여 분 가능한 컴포넌트로 나눠 구성하여 관리하는게 좋다. 컴포넌트 구조가 복잡한 경우, 요청사항에 따라 변경이 까다로울 수 있고 부품을 재사용하기 어렵다. 컴포넌트를 작게 나눠 재사용하는 용도로 구분해 개발하는것이 좋다. 3. props 검사 JavaScript 타입 검사JavaScript는 동적 타입을 사용하는 프로그래밍 언어로 자유도가 높은점이 장점이면서 단점이다. 단점 데이터 타입이 잘못 전달된 경우 문제가 발생해도 오류를 알려주지 않는다. 오류를 알려주지 않기 때문에, 이러한 문제 해결을 위해 함수를 제작할 때 전달 인자의 유효성을 직접 검사해야한다. PropTypes를 활용해 컴포넌트 props 검사React 속성 타입 검사 - 이번 섹션에서 다루는 PropTypes는 규모가 큰 개발일 경우 적합하지 않습니다. - 규모가 큰 경우 Flow 또는 TypeScript를 사용할 것을 권하고 있다.prop-types 패키지 - 설치 npm i prop-types - import로 설치한 prop-types를 불러와주고 자식 속성에서 필요한 데이터의 propType을 설정해주어야 한다. 123456className.propTypes = { name: PropTypes.string.isRequired, // 문자형 필수 number: PropTypes.number.isRequired, // 숫자형 필수 function: PropTypes.func.isRequired, // 함수형 필수 boolean: PropTypes.bool.isRequired, // 불리언 형 필수} 타입 검사 방법 모든 타입 PropTypes.any Number 객체 PropTypes.number string 객체 PropTypes.string Boolean 객체 PropTypes.bool Function 객체 PropTypes.func Array 객체 PropTypes.array Object 객체 PropTypes.object Symbol 객체 PropTypes.symbol Node 객체 PropTypes.node React 객체 PropTypes.element 여러 타입 중 하나 PropTypes.oneOfType([PropTypes.number, PropTypes.string]) 특정 클래스의 인스턴스 PropTypes.instanceOf(Date) 전달 속성 제한 PropTypes.oneOf([‘name’, ‘career’]) 특정 타입 집합으로 제한 PropTypes.arrayOf(PropTypes.string) 특정 타입을 속성 값으로 하는 객체 제한 PropTypes.objectOf(PropTypes.number) 특정 형태를 갖는 객체 제한 PropTypes.shape({prop1, prop2}) PropTypes 속성 기본 값 설정JavaScript(ES6)에서 매개변수 기본 값 매개변수로 값을 전달해 주지 않을 때 message를 매개변수로 받으면 ‘안녕하세요’라는 값을 기본값으로 받는다. React 전달 속성 기본 값 설정 컴포넌트에 전달될 속성의 기본 값을 설정할 때에는 defaultProps속성을 사용하여 기본값을 설정해줄 수 있다. 123456789101112131415161718// 함수 필드 사용시class.defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값}// class 필드 사용시class Class extends Component { // 기본값 설정 static defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값 }} 4. state &amp; 라이프 사이클 훅 클래스 컴포넌트의 state 란? 컴포넌트는 외부로 부터 속성(Props)을 전달 받아 사용할 수 있지만, 전달 받은 속성은 읽기 전용으로 값을 업데이트할 수 없다. state는 컴포넌트가 소유한 로컬 데이터로 적용 범위는 현재 컴포넌트에 한정된다. 필요한 경우, 컴포넌트는 자신의 state를 초기화 하거나 업데이트 할 수 있다. 컴포넌트 라이프 사이클 훅(Life Cycle Hooks) 이란? 생성 will/did -&gt; 업데이트 will/did -&gt; 삭제 will/did Render 단계 (순수하고 부작용이 없다. React에 의해 일시 중지, 중단 또는 재시작 가능) constructor(생성) -&gt; getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render(생성, 업데이트) getDerivedStateFromProps 단계에서 업데이트시 New Props, setState(), forceUpdate() 사용가능 Commit 단계 (DOM을 사용하여 부작용을 실행하고 업데이트를 예약 가능) React DOM 및 refs 업데이트 생성시(componentDidMount), 업데이트시(componentDidUpdate), 제거시(componentWillUnmount) 생성 시점의 라이프 사이클 훅 라이프 사이클의 3단계 Mounting -&gt; 생성 Updating -&gt; 갱신 UnMounting -&gt; 제거 마운팅 시점 라이프 사이클 훅 설명 constructor() 컴포넌트 생성 시점에 호출 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출 render() 컴포넌트 렌더링 시점에 호출 componentDidMount() DOM에 마운트 된 이후 시점에 호출 업데이트, 제거 시점의 라이프 사이클 훅 업데이팅 라이프 사이클 훅 설명 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출(업데이트) shouldComponentUpdate(nextProps, nextState) 컴포넌트 업데이트 예정 시점에 호출(업데이트 하거나, 안하거나) render() 컴포넌트 렌더링(업데이트) getSnapshotBeforeUpdate() 컴포넌트 업데이트 전 스냅샷 가져오는 시점에 호출 componentDidUpdate() 컴포넌트 업데이트 이후 시점에 호출 state 업데이트 React state는 불변 객체이다. React는 state에 변경 대신, 새롭게 교체하는 방법을 사용해 불변 객체를 유지한다. 오류 발생 시점의 라이프 사이클 훅 컴포넌트 렌더링, 라이프 사이클 훅이 실행될 때 오류가 발생한 경우 호출 라이프 사이클 훅 설명 static getDerivedStateFromError() 자손 컴포넌트 오류 발생 시 호출 componentDidCatch() 자손 컴포넌트 오류 발생 시 호출 1234567891011121314state = { hasError: false }// 자식 컴포넌트의 오류를 throw한 후 실행static getDerivedStateFromError(error) { // throw된 오류가 감지되면, hasError 상태 값을 true처리 return { hasError: true }}render() { // 오류 발생시, 레더링 과정에서 오류 메시지를 반환 this.state.hasError &amp;&amp; &lt;h1&gt;오류 발생&lt;/h1&gt; return &lt;div/&gt;}","link":"/react/reactComponent/"},{"title":"React Context","text":"","link":"/react/reactContext/"},{"title":"React Event &amp; Component","text":"React 이벤트 핸들링 &amp; 컴포넌트 통신 React 이벤트 핸들링1. React 이벤트 핸들링 React 요소에서 이벤트를 핸들링 하는 방식은 DOM 요소의 이벤트를 핸들링 방식과 유사하다. 문법적인 차이 이벤트 속성 이름은 camelCase 형식으로 작성 속성 값에 문자열 대신 JSX 형식으로 메서드를 연결(ex: onClick ={ onClickHandler } ) 브라우저 기본 동작을 중단하려면 반드시 e.preventDefault()를 사용 이벤트 핸들러 종류 2. React 이벤트 핸들러와 this e.preventDefault() 메서드 사용 시 this 참조에 대해 주의가 필요하다. 12345constructor(props) { super(this) // 클래스(인스턴스)의 메서드가 클래스(인스턴스)를 가리키도록 바인딩 처림 this.handleLinkClick = this.handleLinkClick.bind(this)} 컴포넌트 통신1. React 컴포넌트 간 통신이 필요한 이유 React 클래스 컴포넌트는 컴포넌트 내에서만 접근 가능한 상태(State)를 가질 수 있어 관리가 용이하지만, 컴포넌트가 중첩되더라도 각 컴포넌트마다 개별적으로 상태를 관리하므로 상태를 공유하는 것이 까다롭다. React 프로그래밍에서는 각 컴포넌트의 상태(데이터)가 스코프 체인 되지 않는다. 효과적인 상태를 관리하기 위해 React 프로그래밍에서는 부모컴포넌트가 상태를 관리하고, 자손 컴포넌트는 부모 컴포넌트와 통신하여 상태 공유를 처리한다. 2. 부모 컴포넌트와 자식 컴포넌트 사이의 props ⇌ callback 부모가 자식 컴포넌트에게 보낼때는 Props 속성을 사용해서 데이터를 전송 (메서드 전송) 자식이 부모 컴포넌트에게 보낼때는 callback을 사용해서 데이터를 전송 (메서드 실행) callback으로 함수를 자식컴포넌트로 전달하여 부모 컴포넌트에서 전달된 함수 데이터를 받는다. 3. 복잡한 컴포넌트 트리 구조에서 props ⇌ callback의 문제 React는 부모에서 자식 컴포넌트로 데이터를 내려오는 구조를 갖고 있기 때문에 복잡한 컴포넌트가 만들어 지면 props와 callback 지옥에 빠질 수 있다. 만약 원하는 데이터를 삭제할 시 해당 데이터를 불러오는 컴포넌트에서 함수를 만들어 준 후 props로 자식 컴포넌트에게 내려주어야 한다. 4. 상태 관리를 효율적으로 관리하기 위한 방법 Context, React Redux Context 활용 React는 중첩된 컴포넌트의 데이터 공유 문제를 해결하기 위한 방법으로 컨텍스트(Context)를 제공한다. Context 사용시 컴포넌트 트리로 묶인 컴포넌트 간에 데이터 공유가 수월해진다. 단점은 컴포넌트를 재사용하기 어렵게 만들기 때문에 꼭 필요한 경우에만 사용하는 것이 좋다. 컨텍스트의 단점을 보안하는 라이브러리 컨텍스트가 완벽한 프로그램이 아니기 때문에 각 컴포넌트가 소유하는데서 기인된 문제 해결 방안으로 상태 관리 시스템인 하나의 저장소에서 관리하도록 만드는 것이다. 다음과 같이 하나의 저장소에서 데이터를 관리 시 각 컴포넌트에서 데이터를 접근하는 여러가지 문제를 해결할 수 있다. 대표적인 상태 관리 라이브러리로 Redux와 Mobx, Vuex 등이 있다.","link":"/react/reactEvent/"},{"title":"React JSX","text":"React JSX1. React 요소를 만드는 2가지 방법 JSX란 =&gt; React 요소 JSX(JavaScript Syntax eXtension)는 HTML과 유사한 문법을 사용해 React요소(JavaScript 객체)를 만들 수 있도록 한다. JavaScript UI view를 구성하는 마크업하는 것은 매우 까다로워 특별한 경우가 아니라면 JSX사용 권장 JSX가 하는 일은 React 요소(Element)를 만드는 것이다. React.createElement()를 사용해 UI view를 구성하는 것을 보다 쉽고 간단한 점이 장점이다. JSX와 React.createElement() 사용하는 방법 JSX가 훨씬 보기 편하고 간단하게 작성 가능 및 가독성이 더 높다.(HTML과 유사) 12345678910// JSXconst app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// ReactElement.createElement()const appHeading = React.createElement('h1', {class: 'app-title'}, 'React.createElement() 메서드')const appElement = React.createElement('div', {class: 'app'}, appHeading) 2. 가상 DOM이란? 실제 DOM에 직접적으로 조작하는 것이 아니라, 이전/이후 상태를 비교하여 변경 사항이 발생할 때 변경된 부분만 실제 DOM에 업데이트(patch)하므로 UI 속도를 향상시킬 수 있다. ReactDom모듈은 React요소로 구성된 가상 DOM을 실제 DOM에 Mount시켜 렌더링해주는 역할을 수행한다. ReactDom.render(container, document.getElementById('root')) 실제 DOM을 사용하는 대표적인 것은 JQuery 가상 DOM을 사용하는 것은 React, View 등 가상 DOM 사용 이유 UI는 사용자의 요구사항에 따라 수시로 변경(업데이트)된다. 업데이트 과정에서 실제 DOM이 변경되면 업데이트 된 요소와 그 자식 요소를 다시 렌더링 해야하는데, 이러한 과정이 UI 속도를 늦춘다. UI 컴포넌트 개수가 많을 수록 렌더링 비용은 더욱 많이 들어 속도는 더더욱 느려지게 된다.(렌더링 비용 UP, 속도 DOWN) 3. JSX 코드가 Babel 컴파일러를 만나면? Babel's Compile JSX를 React.createElement()를 사용해 컴파일한다. 123456789101112131415// JSX 코드const app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// Babel 다음과 같이 컴파일을 함 (React 요소) 가상 DOM을 구성하고 필요에 따라 실제 DOM을 업데이트 한다.const iframeWrapper = React.createElement( // .iframe-wrapper 'div', { className: 'wrapper' }, // .wrapper &gt; h1 React.createElement('h1', {className: 'header'}) // ...으로 속에 코드들을 늘어남) 4. JSX 활용데이터 바인딩이란? JSX란 JavaScript 표현식을 중괄호({})로 묶어 데이터를 바인딩한다. HTML 코드에서 데이터를 빼내 변수에 등록한 후, 변수를 HTML 코드에 바인딩할 수 있다. 이때 데이터는 state 영역의 변수 코드이다. 콘텐츠 바인딩과 JavaScript 표현식 JavaScript 식(Expression)은 항상 값을 반환하므로 {} 안에 바인딩이 가능하다. 중괄호 안에는 문 대신 식을 사용해야한다. 속성 바인딩 (style, className) state나 props로 속성을 변수에 담아 선언해준다. app 중괄호 안에 속성으로 들어가는 값을 넣어주어야 한다. 대표적으로 style 속성등을 넣어주는데 사용한다. 조건 문을 사용한 조건부 렌더링 (if, switch 문) 함수를 생성하여 조건문을 사용해서 처리 후 함수를 렌더링 해주어야 한다. 조건 식을 사용한 사용한 조건부 렌더링 (3항식, 논리연산자) 위의 조건문 보다는 조건식은 바인딩 부분에 바로 사용이 가능하다. 조건 식은 속성 바인딩에도 사용이 가능하다. Array 객체의 map() 메서드를 활용한 리스트 렌더링 state나 props에 배열로 저장되어있는 값을 렌더링 부분에서 .map()매서드를 사용하여 배열을 풀어서 사용할 수 있다. JSX 사용시 주의할 점 속성이름은 CamelCase로 표기 JSX는 HTML이 아니라 JavaScript 식이므로 React DOM은 HTML 표준 속성이름 중 일부는 그대로 사용할 수 없다. 예를 들어 class -&gt; className tabindex -&gt; tabIndex 접근성 속성은 하이픈케이스 사용 예를 들어 aria-label 과 같은 접근성 속성은 하이픈케이스를 사용한다. 컨텐츠가 없는 요소는 항상 닫아야한다. JSX는 XML 문법에 따라 콘텐츠가 없는 빈 요소는 반드시 닫아야한다. 예를들어 &lt;img/&gt; &lt;br/&gt; &lt;area/&gt; 등 루트 요소가 무조건 하나여야 한다. 만약 div로 무의미하게 감싸는 것 보다는 React.Fragment를 사용하는 것이 효율적이다.","link":"/react/reactJSX/"},{"title":"React Base","text":"React란?React는 UI를 구현하는 JavaScript 라이브러리로 현 시점에서 전 세계적으로 가장 사용율이 높으며, 웹 앱, 네이티브 모바일 앱(Android, iOS 등) 개발 등 다양한 플랫폼에서 애플리케이션을 제작하는 공통된 핵심 개발 방법을 제공합니다. React는 컴포넌트 기반 프로그래밍 - 캡슐화 된 컴포넌트 로직은 템플릿이 아닌 JSX(JavaScript+XML)로 사용가능하다. React 시작하기React 러닝 다이어그램1. 공부해야 할 것들1. ES6+ 2. 가상 DOM 3. 컴포넌트화(내부 JSX) 4. 웹 접근성 5. 함수 컴포넌트 2. React 컴포넌트와 요소컴포넌트 요소 React Component는 설계이다. 설계를 사용해서 인스턴스를 만들어 내는데 이때 component는 객체를 반환해주는데 이때 app이라는 변수에 담아 rendering을 시키면 실제 dom요소에서 해당 아이디를 찾아 화면에 보여주게 된다. 12345678910// React Component (Functional)function App() { return &lt;div&gt;React Element&lt;/div&gt; }// React element(JSX)var app = &lt;App/&gt;// ReactDom - renderingReactDOM.render(app, document.querySelector('#app')); 3. React 컴포넌트 구조 이해 및 활용네이티브 컴포넌트 vs 커스텀 컴포넌트 네이티브 컴포넌트를 커스텀 컴포넌트화 하여 중복되는 구조의 함수로 만들어 커스텀하는 요소를 말한다. 이때 react에서는 class를 사용할수 없고 className으로 사용해서 요소에 class를 넣어주어야 한다. React 요소 원하는 함수형 component를 생성하여 html요소처럼 사용이 가능하다. 4. React 프로젝트 생성 with CRA(Create React App) React 프레임 워크 사용해 개발, 배포시에 워크 플로우 개발 단계 npm : 모듈관리 모던 자바스크립트 : ES6 컴포넌트 시스템 : React 개발 서버 : Node.js 애플리케이션 개발 배포 단계 webpack : 번들링, 브라우저 호환성, 최적화 위와 같은 것을 CRA(Create React App)에서 처리해준다. npx create-react-app &lt;프로젝트-이름&gt;을 사용하여 CRA를 사용한 폴더를 생성해준다. 위의 코드 실행시 다음과 같이 폴더가 생성이 된다. 5. React 프로젝트 디렉토리 구조 구조12345678910111213141516- README.md- node_modules/ -&gt; 개발 의존 모듈 집합 디렉토리- package.json- public/ -&gt; 정적 리소스 디렉토리 - favicon.ico - index.html -&gt; 애플리케이션 기본 템플릿 - manifest.json- src/ -&gt; React 애플리케이션 개발 디텍토리 - App.css - App.js -&gt; 애플리케이션 파일 - App.test.js - index.css - index.js -&gt; 엔트리 파일 - logo.svg - serviceWorker.js- yarn.lock public/index.html React 앱이 구성되는 기본 템플릿 파일이다. src/index.js 애플리케이션의 엔트리 파일로 애플리케이션을 구성하는 설정이 포함되어 있다. React : React 모듈 로드 React-dom : React-dom 모듈 로드 렌더함수를 사용해 src/index.html 요소를 내부에 동적으로 App 컴포넌트를 랜더링한다. src/App.js 실질적인 React 앱에 대한 요소 함수형 컴포넌트를 export default로 내보낸다.","link":"/react/reactbase/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"리엑트 공부 순서","slug":"리엑트-공부-순서","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/"},{"name":"React Props","slug":"React-Props","link":"/tags/React-Props/"},{"name":"React State","slug":"React-State","link":"/tags/React-State/"},{"name":"리엑트 컨텍스트","slug":"리엑트-컨텍스트","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"name":"리엑트 이벤트 핸들러","slug":"리엑트-이벤트-핸들러","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC/"},{"name":"리액트 컴포넌트 통신","slug":"리액트-컴포넌트-통신","link":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%86%B5%EC%8B%A0/"},{"name":"리엑트 JSX","slug":"리엑트-JSX","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-JSX/"},{"name":"React 기본","slug":"React-기본","link":"/tags/React-%EA%B8%B0%EB%B3%B8/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"}]}