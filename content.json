{"pages":[{"title":"About","text":"Yh Blog","link":"/about/index.html"}],"posts":[{"title":"용해의 개발 블로그","text":"","link":"/hello-world/"},{"title":"React","text":"React 공부 순서 React 기초 React Props와 State React JSX React 이벤트 핸들러와 컴포넌트 통신 React Context &amp; 고차 컴포넌트 React 폼 컨트롤러 React 훅(Hook)과 접근성","link":"/react/index/"},{"title":"React Props &amp; State","text":"React Props &amp; State 1. React 컴포넌트와 전달 속성(props) React 컴포넌트로 props를 전달할 수 있다. 상위 컴포넌트에서 하위 컴포넌트로 props를 넘겨주는데 이때 상위에서 데이터를 다음과 같이 전달해 준다. 1234567891011121314151617181920212223// React Componentfunction MenuListItem(props) { return &lt;li&gt; &lt;h3&gt;{props.caption}&lt;/h3&gt; &lt;/li&gt;}// 위의 컴포넌트를 아래에서 사용function MenuList() { // 다음과 같이 Props를 전달해고 위에서처럼 값을 전달 받을수 있다. return &lt;ul&gt; &lt;MenuListItem caption = &quot;props 전달 1&quot; /&gt; &lt;MenuListItem caption = &quot;props 전달 2&quot; /&gt; &lt;/ul&gt;}// 위의 컴포넌트를 아래에서 사용function App() { return &lt;main&gt; &lt;h2&gt;&lt;/h2&gt; &lt;MenuList/&gt; &lt;/main&gt;} 2. 컴포넌트 &amp; props 컴포넌트 UI를 구성하는 조각에 해당되며, 독립적으로 분리되어 재사용을 목표로 사용한다. React 앱에서 컴포넌트는 개별적인 JavaScript 파일로 분리되어 관리한다. React 함수형 컴포넌트 함수형 컴포넌트 React 컴포넌트는 개념상 JavaScript 함수와 유사하다. 컴포넌트 외부로부터 속성(props)을 전달 받아 어떻게 UI를 구성해야 할지 설정하여 React요소(JXL를 Babel이 변환 처리)로 반환된다. 문법 구문을 사용하는 컴포넌트를 React는 함수형으로 분류한다. 컴포넌트 이름은 항상 대문자로 시작하는 TitleCase문법 사용이 권징된다. (HTML 표준 요소와 구별하기 위함) React 클래스 컴포넌트 ES6부터 지원됨 vsCode에서 React pure to Class를 선택해주면 함수형 컴포넌트를 class형 컴포넌트로 나눌수 있다. 클래스 컴포넌트 vs 함수형 컴포넌트 React에서는 두 컴포넌트는 유사하다. 클래스 컴포넌트의 경우 함수형 컴포넌트에 없는 기능을 추가적으로 사용 가능하다. React 컴포넌트 import,export / props 다른 파일로 자식 컴포넌트 분리 후 export로 파일 저장 -&gt; import로 자식 컴포넌트를 부모 컴포넌트에서 불러온다. props(전달속성) 컴포넌트에서 설정된 임의의 JSX 속성(type, children 등)은 React에 의해 컴포넌트 속성(props) 객체로 전달한다. 부모 -&gt; 자식으로 데이터를 넘길 때 사용(부모에서 props로 데이터를 넘김) 컴포넌트에 전달된 속성 객체는 읽기전용이라 수정이 불가능하다. 이때 수정을 하기위해서는 props 대신 state를 활용해야한다. React 컴포넌트 관리 (추출) 컴포넌트 트리 최상위 부모에는 App파일이 되어야하고 그안에 여러 컴포넌트를 나눠 중복 또는 반복되는 부분을 바꾸어 주어야한다. 컴포넌트 추출 컴포넌트 내부에서 컴포넌트로 사용할 수 있는 것이 보인다면 분리하는 것이 좋다. 복잡한 컴포넌트 내부에서 세분화하여 분 가능한 컴포넌트로 나눠 구성하여 관리하는게 좋다. 컴포넌트 구조가 복잡한 경우, 요청사항에 따라 변경이 까다로울 수 있고 부품을 재사용하기 어렵다. 컴포넌트를 작게 나눠 재사용하는 용도로 구분해 개발하는것이 좋다. 3. props 검사 JavaScript 타입 검사JavaScript는 동적 타입을 사용하는 프로그래밍 언어로 자유도가 높은점이 장점이면서 단점이다. 단점 데이터 타입이 잘못 전달된 경우 문제가 발생해도 오류를 알려주지 않는다. 오류를 알려주지 않기 때문에, 이러한 문제 해결을 위해 함수를 제작할 때 전달 인자의 유효성을 직접 검사해야한다. PropTypes를 활용해 컴포넌트 props 검사React 속성 타입 검사 - 이번 섹션에서 다루는 PropTypes는 규모가 큰 개발일 경우 적합하지 않습니다. - 규모가 큰 경우 Flow 또는 TypeScript를 사용할 것을 권하고 있다.prop-types 패키지 - 설치 npm i prop-types - import로 설치한 prop-types를 불러와주고 자식 속성에서 필요한 데이터의 propType을 설정해주어야 한다. 123456className.propTypes = { name: PropTypes.string.isRequired, // 문자형 필수 number: PropTypes.number.isRequired, // 숫자형 필수 function: PropTypes.func.isRequired, // 함수형 필수 boolean: PropTypes.bool.isRequired, // 불리언 형 필수} 타입 검사 방법 모든 타입 PropTypes.any Number 객체 PropTypes.number string 객체 PropTypes.string Boolean 객체 PropTypes.bool Function 객체 PropTypes.func Array 객체 PropTypes.array Object 객체 PropTypes.object Symbol 객체 PropTypes.symbol Node 객체 PropTypes.node React 객체 PropTypes.element 여러 타입 중 하나 PropTypes.oneOfType([PropTypes.number, PropTypes.string]) 특정 클래스의 인스턴스 PropTypes.instanceOf(Date) 전달 속성 제한 PropTypes.oneOf([‘name’, ‘career’]) 특정 타입 집합으로 제한 PropTypes.arrayOf(PropTypes.string) 특정 타입을 속성 값으로 하는 객체 제한 PropTypes.objectOf(PropTypes.number) 특정 형태를 갖는 객체 제한 PropTypes.shape({prop1, prop2}) PropTypes 속성 기본 값 설정JavaScript(ES6)에서 매개변수 기본 값 매개변수로 값을 전달해 주지 않을 때 message를 매개변수로 받으면 ‘안녕하세요’라는 값을 기본값으로 받는다. React 전달 속성 기본 값 설정 컴포넌트에 전달될 속성의 기본 값을 설정할 때에는 defaultProps속성을 사용하여 기본값을 설정해줄 수 있다. 123456789101112131415161718// 함수 필드 사용시class.defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값}// class 필드 사용시class Class extends Component { // 기본값 설정 static defaultProps = { name: 'string값', number: 1, // number값 func: () =&gt; console.log('function값'), boolean: true, // Boolean 값 }} 4. state &amp; 라이프 사이클 훅 클래스 컴포넌트의 state 란? 컴포넌트는 외부로 부터 속성(Props)을 전달 받아 사용할 수 있지만, 전달 받은 속성은 읽기 전용으로 값을 업데이트할 수 없다. state는 컴포넌트가 소유한 로컬 데이터로 적용 범위는 현재 컴포넌트에 한정된다. 필요한 경우, 컴포넌트는 자신의 state를 초기화 하거나 업데이트 할 수 있다. 컴포넌트 라이프 사이클 훅(Life Cycle Hooks) 이란? 생성 will/did -&gt; 업데이트 will/did -&gt; 삭제 will/did Render 단계 (순수하고 부작용이 없다. React에 의해 일시 중지, 중단 또는 재시작 가능) constructor(생성) -&gt; getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render(생성, 업데이트) getDerivedStateFromProps 단계에서 업데이트시 New Props, setState(), forceUpdate() 사용가능 Commit 단계 (DOM을 사용하여 부작용을 실행하고 업데이트를 예약 가능) React DOM 및 refs 업데이트 생성시(componentDidMount), 업데이트시(componentDidUpdate), 제거시(componentWillUnmount) 생성 시점의 라이프 사이클 훅 라이프 사이클의 3단계 Mounting -&gt; 생성 Updating -&gt; 갱신 UnMounting -&gt; 제거 마운팅 시점 라이프 사이클 훅 설명 constructor() 컴포넌트 생성 시점에 호출 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출 render() 컴포넌트 렌더링 시점에 호출 componentDidMount() DOM에 마운트 된 이후 시점에 호출 업데이트, 제거 시점의 라이프 사이클 훅 업데이팅 라이프 사이클 훅 설명 static getDerivedFromProps() 전달된 상태 및 속성을 가져와 설정하는 시점에 호출(업데이트) shouldComponentUpdate(nextProps, nextState) 컴포넌트 업데이트 예정 시점에 호출(업데이트 하거나, 안하거나) render() 컴포넌트 렌더링(업데이트) getSnapshotBeforeUpdate() 컴포넌트 업데이트 전 스냅샷 가져오는 시점에 호출 componentDidUpdate() 컴포넌트 업데이트 이후 시점에 호출 state 업데이트 React state는 불변 객체이다. React는 state에 변경 대신, 새롭게 교체하는 방법을 사용해 불변 객체를 유지한다. 오류 발생 시점의 라이프 사이클 훅 컴포넌트 렌더링, 라이프 사이클 훅이 실행될 때 오류가 발생한 경우 호출 라이프 사이클 훅 설명 static getDerivedStateFromError() 자손 컴포넌트 오류 발생 시 호출 componentDidCatch() 자손 컴포넌트 오류 발생 시 호출 1234567891011121314state = { hasError: false }// 자식 컴포넌트의 오류를 throw한 후 실행static getDerivedStateFromError(error) { // throw된 오류가 감지되면, hasError 상태 값을 true처리 return { hasError: true }}render() { // 오류 발생시, 레더링 과정에서 오류 메시지를 반환 this.state.hasError &amp;&amp; &lt;h1&gt;오류 발생&lt;/h1&gt; return &lt;div/&gt;}","link":"/react/reactComponent/"},{"title":"React Context","text":"React Context와 고차 컴포넌트(HOC) 컨텍스트(Context)1. Context의 Provider, Consumer를 사용한 데이터 공유 Context는 React 컴포넌트 트리안에서 데이터를 글로벌하게 공유할 수 있도록 고안된 방법이다. Context의 Provider는 데이터를 가지고 있는 부모 컴포넌트를 뜻하고 Consumer는 데이터를 받고 싶은 자식 컴포넌트를 뜻한다. 사용 방법12345678910// Context 생성하고 초기값을 설정const Context = React.createContext(false);// 부모 컴포넌트에서 보내줄 데이터 설정&lt;Context.Provider value={this.state.value} /&gt;// 자식 컴포넌트에서 값 받기&lt;Context.Consumer&gt;&lt;/Context.Consumer&gt; 다른 파일에서 사용시에는 export를 사용해서 내보내준다. 2. Context 모듈을 활용해 개별 컴포넌트에서 데이터 공유 Context 분리 및 변경 메서드를 가진 context를 관리하는 파일을 생성한다. 부모, 자식 컴포넌트에서 분리한 context를 import하여 똑같이 사용해주면 된다. 3. Context Type 활용 Context Type은 컨텍스트 객체를 클래스 컴포넌트의 ContextType Static 속성으로 지정해 활용하는 방법이다. this.context를 사용해서 접근 가능 Context Type 사용하면 Context.Consumer를 생략하고 this.context를 사용해서 데이터를 빼와서 사용 가능하다. 그러나 공급자인 context.Provider는 생략 불가하다. Context Type을 사용하면 단 하나의 컨텍스트 객체만 사용 가능하다. 하나 이상의 컨텍스트 객체를 Context.Consumer를 중첩 사용해야한다. 자세한 Context에 대한 내용 참고 고차 컴포넌트(HOC)1. 고차 함수(HOF)란? 고차 함수의 조건 함수형 프로그래밍에서 함수는 값(Value)으로 취급된다. 함수에 숫자, 문자, 데이터를 전달하듯 함수 또한 다른 함수에 값으로 전달할 수 있다. 함수를 값으로 반환하는 것도 가능하다. 하나 이상의 함수를 인자로 전달 받는다. ((fn) =&gt; {}) 함수를 결과로 반환 한다. (() =&gt; fn) React에서는 Array의 map() 매서드가 고차함수이다. 2. 고차 컴포넌트(HOC)란? 고차 컴포넌트는 컴포넌트 로직을 재사용하기 위한 React 고급 프로그래밍 기술이다. 컴포넌트를 전달받아 새로운 컴포넌트를 반환하는 함수이다. 일반 컴포넌트가 UI를 반환하지만, 고차 컴포넌트는 컴포넌트를 반환한다. HOC는 Redux connect 함수, React Router withRouter 함수, Relay createFragmentContainer 함수 등 다양한 React 라이브러리에서 일반적으로 사용된다. 3. 사용자 정의 고차 컴포넌트 컴포넌트에서는 class 컴포넌트를 사용하여서 context를 불러와야한다.","link":"/react/reactContext/"},{"title":"React Event &amp; Component","text":"React 이벤트 핸들링 &amp; 컴포넌트 통신 React 이벤트 핸들링1. React 이벤트 핸들링 React 요소에서 이벤트를 핸들링 하는 방식은 DOM 요소의 이벤트를 핸들링 방식과 유사하다. 문법적인 차이 이벤트 속성 이름은 camelCase 형식으로 작성 속성 값에 문자열 대신 JSX 형식으로 메서드를 연결(ex: onClick ={ onClickHandler } ) 브라우저 기본 동작을 중단하려면 반드시 e.preventDefault()를 사용 이벤트 핸들러 종류 2. React 이벤트 핸들러와 this e.preventDefault() 메서드 사용 시 this 참조에 대해 주의가 필요하다. 12345constructor(props) { super(this) // 클래스(인스턴스)의 메서드가 클래스(인스턴스)를 가리키도록 바인딩 처림 this.handleLinkClick = this.handleLinkClick.bind(this)} 컴포넌트 통신1. React 컴포넌트 간 통신이 필요한 이유 React 클래스 컴포넌트는 컴포넌트 내에서만 접근 가능한 상태(State)를 가질 수 있어 관리가 용이하지만, 컴포넌트가 중첩되더라도 각 컴포넌트마다 개별적으로 상태를 관리하므로 상태를 공유하는 것이 까다롭다. React 프로그래밍에서는 각 컴포넌트의 상태(데이터)가 스코프 체인 되지 않는다. 효과적인 상태를 관리하기 위해 React 프로그래밍에서는 부모컴포넌트가 상태를 관리하고, 자손 컴포넌트는 부모 컴포넌트와 통신하여 상태 공유를 처리한다. 2. 부모 컴포넌트와 자식 컴포넌트 사이의 props ⇌ callback 부모가 자식 컴포넌트에게 보낼때는 Props 속성을 사용해서 데이터를 전송 (메서드 전송) 자식이 부모 컴포넌트에게 보낼때는 callback을 사용해서 데이터를 전송 (메서드 실행) callback으로 함수를 자식컴포넌트로 전달하여 부모 컴포넌트에서 전달된 함수 데이터를 받는다. 3. 복잡한 컴포넌트 트리 구조에서 props ⇌ callback의 문제 React는 부모에서 자식 컴포넌트로 데이터를 내려오는 구조를 갖고 있기 때문에 복잡한 컴포넌트가 만들어 지면 props와 callback 지옥에 빠질 수 있다. 만약 원하는 데이터를 삭제할 시 해당 데이터를 불러오는 컴포넌트에서 함수를 만들어 준 후 props로 자식 컴포넌트에게 내려주어야 한다. 4. 상태 관리를 효율적으로 관리하기 위한 방법 Context, React Redux Context 활용 React는 중첩된 컴포넌트의 데이터 공유 문제를 해결하기 위한 방법으로 컨텍스트(Context)를 제공한다. Context 사용시 컴포넌트 트리로 묶인 컴포넌트 간에 데이터 공유가 수월해진다. 단점은 컴포넌트를 재사용하기 어렵게 만들기 때문에 꼭 필요한 경우에만 사용하는 것이 좋다. 컨텍스트의 단점을 보안하는 라이브러리 컨텍스트가 완벽한 프로그램이 아니기 때문에 각 컴포넌트가 소유하는데서 기인된 문제 해결 방안으로 상태 관리 시스템인 하나의 저장소에서 관리하도록 만드는 것이다. 다음과 같이 하나의 저장소에서 데이터를 관리 시 각 컴포넌트에서 데이터를 접근하는 여러가지 문제를 해결할 수 있다. 대표적인 상태 관리 라이브러리로 Redux와 Mobx, Vuex 등이 있다.","link":"/react/reactEvent/"},{"title":"React JSX","text":"React JSX 1. React 요소를 만드는 2가지 방법 JSX란 =&gt; React 요소 JSX(JavaScript Syntax eXtension)는 HTML과 유사한 문법을 사용해 React요소(JavaScript 객체)를 만들 수 있도록 한다. JavaScript UI view를 구성하는 마크업하는 것은 매우 까다로워 특별한 경우가 아니라면 JSX사용 권장 JSX가 하는 일은 React 요소(Element)를 만드는 것이다. React.createElement()를 사용해 UI view를 구성하는 것을 보다 쉽고 간단한 점이 장점이다. JSX와 React.createElement() 사용하는 방법 JSX가 훨씬 보기 편하고 간단하게 작성 가능 및 가독성이 더 높다.(HTML과 유사) 12345678910// JSXconst app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// ReactElement.createElement()const appHeading = React.createElement('h1', {class: 'app-title'}, 'React.createElement() 메서드')const appElement = React.createElement('div', {class: 'app'}, appHeading) 2. 가상 DOM이란? 실제 DOM에 직접적으로 조작하는 것이 아니라, 이전/이후 상태를 비교하여 변경 사항이 발생할 때 변경된 부분만 실제 DOM에 업데이트(patch)하므로 UI 속도를 향상시킬 수 있다. ReactDom모듈은 React요소로 구성된 가상 DOM을 실제 DOM에 Mount시켜 렌더링해주는 역할을 수행한다. ReactDom.render(container, document.getElementById('root')) 실제 DOM을 사용하는 대표적인 것은 JQuery 가상 DOM을 사용하는 것은 React, View 등 가상 DOM 사용 이유 UI는 사용자의 요구사항에 따라 수시로 변경(업데이트)된다. 업데이트 과정에서 실제 DOM이 변경되면 업데이트 된 요소와 그 자식 요소를 다시 렌더링 해야하는데, 이러한 과정이 UI 속도를 늦춘다. UI 컴포넌트 개수가 많을 수록 렌더링 비용은 더욱 많이 들어 속도는 더더욱 느려지게 된다.(렌더링 비용 UP, 속도 DOWN) 3. JSX 코드가 Babel 컴파일러를 만나면? Babel's Compile JSX를 React.createElement()를 사용해 컴파일한다. 123456789101112131415// JSX 코드const app = ( &lt;div className=&quot;app&quot;&gt; &lt;h1&gt;React App&lt;/h1&gt; &lt;/div&gt;)// Babel 다음과 같이 컴파일을 함 (React 요소) 가상 DOM을 구성하고 필요에 따라 실제 DOM을 업데이트 한다.const iframeWrapper = React.createElement( // .iframe-wrapper 'div', { className: 'wrapper' }, // .wrapper &gt; h1 React.createElement('h1', {className: 'header'}) // ...으로 속에 코드들을 늘어남) 4. JSX 활용데이터 바인딩이란? JSX란 JavaScript 표현식을 중괄호({})로 묶어 데이터를 바인딩한다. HTML 코드에서 데이터를 빼내 변수에 등록한 후, 변수를 HTML 코드에 바인딩할 수 있다. 이때 데이터는 state 영역의 변수 코드이다. 콘텐츠 바인딩과 JavaScript 표현식 JavaScript 식(Expression)은 항상 값을 반환하므로 {} 안에 바인딩이 가능하다. 중괄호 안에는 문 대신 식을 사용해야한다. 속성 바인딩 (style, className) state나 props로 속성을 변수에 담아 선언해준다. app 중괄호 안에 속성으로 들어가는 값을 넣어주어야 한다. 대표적으로 style 속성등을 넣어주는데 사용한다. 조건 문을 사용한 조건부 렌더링 (if, switch 문) 함수를 생성하여 조건문을 사용해서 처리 후 함수를 렌더링 해주어야 한다. 조건 식을 사용한 사용한 조건부 렌더링 (3항식, 논리연산자) 위의 조건문 보다는 조건식은 바인딩 부분에 바로 사용이 가능하다. 조건 식은 속성 바인딩에도 사용이 가능하다. Array 객체의 map() 메서드를 활용한 리스트 렌더링 state나 props에 배열로 저장되어있는 값을 렌더링 부분에서 .map()매서드를 사용하여 배열을 풀어서 사용할 수 있다. JSX 사용시 주의할 점 속성이름은 CamelCase로 표기 JSX는 HTML이 아니라 JavaScript 식이므로 React DOM은 HTML 표준 속성이름 중 일부는 그대로 사용할 수 없다. 예를 들어 class -&gt; className tabindex -&gt; tabIndex 접근성 속성은 하이픈케이스 사용 예를 들어 aria-label 과 같은 접근성 속성은 하이픈케이스를 사용한다. 컨텐츠가 없는 요소는 항상 닫아야한다. JSX는 XML 문법에 따라 콘텐츠가 없는 빈 요소는 반드시 닫아야한다. 예를들어 &lt;img/&gt; &lt;br/&gt; &lt;area/&gt; 등 루트 요소가 무조건 하나여야 한다. 만약 div로 무의미하게 감싸는 것 보다는 React.Fragment를 사용하는 것이 효율적이다.","link":"/react/reactJSX/"},{"title":"React Base","text":"React란?React는 UI를 구현하는 JavaScript 라이브러리로 현 시점에서 전 세계적으로 가장 사용율이 높으며, 웹 앱, 네이티브 모바일 앱(Android, iOS 등) 개발 등 다양한 플랫폼에서 애플리케이션을 제작하는 공통된 핵심 개발 방법을 제공합니다. React는 컴포넌트 기반 프로그래밍 - 캡슐화 된 컴포넌트 로직은 템플릿이 아닌 JSX(JavaScript+XML)로 사용가능하다. React 시작하기React 러닝 다이어그램1. 공부해야 할 것들 ES6+ 가상 DOM 컴포넌트화(내부 JSX) 웹 접근성 함수 컴포넌트 2. React 컴포넌트와 요소컴포넌트 요소 React Component는 설계이다. 설계를 사용해서 인스턴스를 만들어 내는데 이때 component는 객체를 반환해주는데 이때 app이라는 변수에 담아 rendering을 시키면 실제 dom요소에서 해당 아이디를 찾아 화면에 보여주게 된다. 12345678910// React Component (Functional)function App() { return &lt;div&gt;React Element&lt;/div&gt; }// React element(JSX)var app = &lt;App/&gt;// ReactDom - renderingReactDOM.render(app, document.querySelector('#app')); 3. React 컴포넌트 구조 이해 및 활용네이티브 컴포넌트 vs 커스텀 컴포넌트 네이티브 컴포넌트를 커스텀 컴포넌트화 하여 중복되는 구조의 함수로 만들어 커스텀하는 요소를 말한다. 이때 react에서는 class를 사용할수 없고 className으로 사용해서 요소에 class를 넣어주어야 한다. React 요소 원하는 함수형 component를 생성하여 html요소처럼 사용이 가능하다. 4. React 프로젝트 생성 with CRA(Create React App) React 프레임 워크 사용해 개발, 배포시에 워크 플로우 개발 단계 npm : 모듈관리 모던 자바스크립트 : ES6 컴포넌트 시스템 : React 개발 서버 : Node.js 애플리케이션 개발 배포 단계 webpack : 번들링, 브라우저 호환성, 최적화 위와 같은 것을 CRA(Create React App)에서 처리해준다. npx create-react-app &lt;프로젝트-이름&gt;을 사용하여 CRA를 사용한 폴더를 생성해준다. 위의 코드 실행시 다음과 같이 폴더가 생성이 된다. 5. React 프로젝트 디렉토리 구조 구조12345678910111213141516- README.md- node_modules/ -&gt; 개발 의존 모듈 집합 디렉토리- package.json- public/ -&gt; 정적 리소스 디렉토리 - favicon.ico - index.html -&gt; 애플리케이션 기본 템플릿 - manifest.json- src/ -&gt; React 애플리케이션 개발 디텍토리 - App.css - App.js -&gt; 애플리케이션 파일 - App.test.js - index.css - index.js -&gt; 엔트리 파일 - logo.svg - serviceWorker.js- yarn.lock public/index.html React 앱이 구성되는 기본 템플릿 파일이다. src/index.js 애플리케이션의 엔트리 파일로 애플리케이션을 구성하는 설정이 포함되어 있다. React : React 모듈 로드 React-dom : React-dom 모듈 로드 렌더함수를 사용해 src/index.html 요소를 내부에 동적으로 App 컴포넌트를 랜더링한다. src/App.js 실질적인 React 앱에 대한 요소 함수형 컴포넌트를 export default로 내보낸다.","link":"/react/reactbase/"},{"title":"React 폼 컨트롤러","text":"React 폼 컨트롤러 HTML VS React 폼 컨트롤 HTML Form 컨트롤러 방식 &lt;input/&gt;, &lt;textarea/&gt;, &lt;select/&gt; 등 사용자의 입력 콘텐츠를 자체적으로 관리한다. React Form 컨트롤러 방식 React는 컴포넌트 상태 정보를 state 속성으로 관리하며 setState()메서드를 사용해 상태를 업데이트한다.12// 다음과 같이 사용하여 입력한 value가 바로 state에 업데이트 되도록하여 입력한 값이 보이도록 하였다. &lt;input type=&quot;text&quot; value={this.state.inputValue}/&gt; AppInput 컴포넌트 (사용자 정의) 좀 더 자세한 Form에 대한 설명 input Form 컨트롤러를 따로 컴포넌트로 분리하여 사용한다. React 폼 멀티플 컨트롤 핸들링 하나의 컴포넌트를 사용하여 여러 input 컴포넌트를 생성하여 하나의 핸들러로 여러개를 관리할수 있다. &lt;textarea&gt; 컨트롤러 HTML의 &lt;textarea&gt;요소는 사용자가 입력한 내용을 자식 텍스트 콘텐츠로 받는다. React는 value 속성을 대신 사용하여 텍스트를 받아와야한다. 한줄 입력을 사용하는 폼 컨트롤러와 비슷하게 사용한다. 컨트롤 vs 언 컨트롤 컴포넌트, ref 속성 Uncontrolled 컴포넌트 컴트롤 할 수 없는 컴포넌트는 form요소가 React 외부에서 작동하는 것처럼 작동한다. 사용자가 form 필드(input box, dropdown 등)에 데이터를 입력하면 업데이트 된 정보가 React에서 별도 처리할 필요 없이 요소에 반영된다. File 인풋 요소 HTML에서 &lt;input type=&quot;file&quot; /&gt; 요소는 사용자가 하나 이상의 파일을 자신의 로컬 컴퓨터에서 서버로 업로드한다. 이 컴포넌트는 프로그래밍 적으로 값을 설정할 수 없고, 사용자만이 값을 설정할 수 있기 때문에 컨트롤 할 수 없는 컴포넌트 즉, 언 컨트롤 컴포넌트이다. 이때 컨트롤 할 수 없는 컴포넌트의 경우 DOM 자체에서 폼 데이터를 다루게 된다. 모든 state업데이트에 대한 이벤트 핸들러를 작성하는 대신 제어할 수 없는 컴포넌트를 만들려면 ref 속성을 사용해 DOM에서 폼 값을 가져올 수 있다. Ref 객체 참조 ref 속성은 render()메서드에서 생성된 DOM 노드나 React 요소에 접근하는 방법이다.","link":"/react/reactForm/"},{"title":"React 훅(Hook)과 접근성","text":"React Hook &amp; 접근성 React Hook1. React 클래스 컴포넌트 → 함수형 컴포넌트로 전환 (상태 관리) 상태 관리는 state를 useState를 사용해서 관리한다. useState는 React에서 import해와야한다. 123456789101112131415import React,{useState} from 'react';function App() { // 배열에 첫번째는 state 이름, 두번쨰는 setState로 값을 변경해주는 함수명 입력, useState()의 괄호 안에는 기본값을 넣어준다. const [state, setState] = useState(default); // 함수를 정의하여 작성 const functions = () &gt; { } // return 값 안에 HTML 구조 작성 return( &lt;div&gt;&lt;/div&gt; )} 2. 메서드를 활용한 사이드 이펙트 처리 useEffect()사용하기 componentDidMount와 componentDidUpdate등을 한번에 처리해주는 부분 123456789101112131415161718192021222324252627let bool = true;function component(props) { useEffect(() =&gt; { if(bool) { // componentDidMount } // componentDidUpdate return () =&gt; { // componentWillUnmount } }) // 특정 props만 관리하고 싶을 경우 useEffect(() =&gt; { if(bool) { // componentDidMount } // componentDidUpdate return () =&gt; { // componentWillUnmount } }, [ // 관리하고 싶은 props ])} 3. 메서드를 활용한 DOM 노드 접근/조작 useRef useRef()는 실제 DOM노드를 참조 할 경우 사용하며, 참조 대항의 변경이 필요한 경우 .current속성을 사용한다. useRef()는 컴포넌트가 다시 그려지지 않는 점에 주의해야한다. 이때는 useCallback()훅을 사용하여 컴포넌트 state를 업데이트하여 컴포넌트를 다시 그리게 해주어야한다. 다음과 같은 방식으로 사용 12345678910111213141516171819202122function Image() { const [image, setImage] = useState({ src: '', alt: '' }); const image = useRef(null); const changeImage = (path) =&gt; { setImage({ src: path, alr: '설명' }) } return( &lt;div&gt; &lt;img src={image.src}&gt; &lt;button type=&quot;button&quot; onClick={() =&gt; changeImagePath('pathName')}&gt;이미지 변경&lt;/button&gt; &lt;/div&gt; )} 4. 메서드를 활용한 컨텍스트 데이터 공유 useContext useContext() 훅은 클래스 컴포넌트의 static contextType 또는 &lt;Context.Consumer&gt;와 동일하며, 컨텍스트를 읽고, 변경사항을 구독하는 것만 가능하다. 컨텍스트의 값을 변경하려면 &lt;Context.Provider&gt;가 필요하다. 기존에 고차 컨텍스트인 static Context, contextType 사용하지 않고 간단하게 사용 가능하다. 접근성React-axe 패키지 모듈을 활용한 접근성 자동 검사 React-axe란 axe-core 테스트 도구를 래핑한 React-axe라이버러리는 React 엡의 모든 페이지 접근성을 자동으로 검사하여 개발자에게 실시간 피드백을 전달한다. 피드백을 확인하고 문제를 해결함으로 잠재적인 접근성 문제를 미연에 방지할 수 있다. npm i react-axe -D를 사용하여 react-axe를 설치하여 준다. index.js에서 사용하여야 주어야 한다. 1234if (process.env.NODE_ENV !== 'production') { // axe는 1번째인자로 React, 2번째는 ReactDOM, 3번째는 앱 실행 후 몇초뒤에 실행할지 설정값을 넣어준다. 밑에서는 1초로 설정하였다. axe(React, ReactDOM, 1000);} 개발상태에서만 axe를 사용해준다. 만약 오류 발생신 console창에서 axe오류(접근성에 대한 오류)를 발생 시켜준다. axe-core 확인 시 오류를 한국어로 표시할 수 있게 바꿔줄수 있다. 이때 src 폴더 안에 axe-locale이라는 폴더를 생성 후에 index.js파일에서 import해주면 한글로 바꿔서 오류를 표시해줄 수 있다. axe-core를 설치한 후 ko.json 파일을 생성 후 axe-locale-ko.js 파일 생성 후 다음과 같이 생성해준다.1234import axeCore from 'axe-core';import ko from './ko.json';axeCore.configure({ locale: ko });","link":"/react/reactHook/"},{"title":"React 팁","text":"React 팁 1. 절대경로 임포트 (jsconfig.json 설정) 절대 경로로 바꾸는 법 jsconfig.json 파일에 다음 코드 추가 123456{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;src&quot;}, &quot;include&quot;: [&quot;src&quot;]} 설정 후에는 상대 경로 대신 아래와 같은 절대 경로를 사용하여 컴포넌트 불러오기 src 안에 있는 파일을 ./과 ../ 없이도 찾아 올수 있다. 2. ReactComponent를 활용한 SVG 이미지 스타일링 &amp; 애니메이션 SVG 파일을 React 프로젝트에서 사용할 경우, 아래 예시 코드처럼 이미지 경로를 가져와 &lt;img/&gt;요소의 src 속성 값으로 사용해 이미지를 그려내야한다.12345// 이미지 경로 처리import logo from './assets/logo.svg';// img 요소의 src 값으로 처리const reactLogo = &lt;img src={logo} alt=&quot;React 로고&quot; /&gt;; img 요소로 호출된 SVG 그래픽은 여러 제약이 있다. 위의 제약 때문에 ReactComponent를 사용하여 SVG를 불러오는 것이 style과 애니메이션 사용에 더 용이하다. 3. Sass를 활용한 스타일 모듈화 css 프리포로세서인 Sass를 Create-React-App으로 새성한 프로젝트에서 사용하려면 node-sass 모듈을 설치해야한다. 설치 순서 npm i node-sass를 사용해서 설치 파일명.scss와 같은 형식으로 사용 4. CSS 모듈을 사용해 고유한 클래스 이름 생성(스타일 충돌 방지) css 모듈 똑같은 css명을 사용할때 충돌을 방지하기 위해 고유성을 지키기 위해 css 모듈을 사용한다. 5. craco를 활용해 설정 덮어쓰기 (Sass 소스맵 설정) craco 사용 이유 CRA를 사용해 제작한 프로젝트 설정을 변경하려면 eject명령을 사용해야 하고, 한번 eject하면 되돌릴 수 없다. 위의 불편을 감수하는 대신 Craco를 사용하여 꺼내기를 하지 않고도 CRA 설정을 덮어 쓸 수 있다. craco 사용 방법 npm i craco를 사용하여 설치 craco.config.js 파일을 프로젝트 루트에 생성123module.exports = ({env}) =&gt; { return {}} package.json파일에 scripts 부분을 eject를 제외한 나머비 부분을 ‘react-scripts’ -&gt; ‘craco’로 변경해준다. 생성해 놓았던 craco.config.js파일에 sourceMap 옵션이 정상적으로 작용하도록 설정1234567const sassSourcemapsPlugin = require('./config/plugins/craco-sass-sourcemap');module.exports = { pulgins: [ { plugin : sassSourcemapsPlugin } ] } ./config/plugins/craco-sass-sourcemap 해당 루트에 파일 생성12345678910111213141516171819202122232425262728293031323334353637module.exports = { overrideWeppackConfig : ({ webpackConfig, cracoConfig, pluginOptions, context: { env, paths } }) =&gt; { function traverse(obj, callback) { if (Array.isArray(obj)) { obj.forEach((item) =&gt; traverse(item, callback)) } else if (typeof obj === 'object' &amp;&amp; obj !== null) { Object.keys(obj).forEach((key) =&gt; { if (obj.hasOwnProperty(key)) { callback(obj, key); traverse(obj[key], callback); } }) } } traverse(weppackConfig, (node, key) =&gt; { if(key === 'loader') { if( node[key].indexOf('sass-loader') !== -1 || node[key].indexOf('postcss-loader') !== -1 || node[key].indexOf('css-loader') !== -1 ) { if(node.options) { node.options.sourceMap = true; } } } }); return webpackConfig; },} 각 scss 파일의 코드를 sources에서 명시적으로 볼 수 있다. 자세한 설명 6. classNames() 유틸리티 활용 classNames() 사용 이유 React에서 css 클래스 속성을 사용 시 동작 또는 조건 처리하여 결합하는 JS유틸리티 함수이다. 자세한 설명 사용 방법 npm i classnames사용하여 설치 코드에서 다음과 같이 사용한다.12345678910111213141516171819202122232425262728293031 // scss 파일 불러오기 import styles from 'styles.scss'; import classNames from 'classnames/bind'; let cx = classNames.bind(styles); ``` ## 7. React 컴포넌트 / 유닛 테스트 디버깅- React 컴포넌트 디버깅 - VSCode에서 [Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome)을 설치하여 React 컴포넌트를 디버깅한다. - 설치가 완료되면 디버깅패널을 열어 chrome 실행 스크립트를 구성해주어야 한다. ```json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Debug CRA&quot;, &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;${workspaceRoot}/src&quot;, &quot;sourceMapPathOverrides&quot;: { &quot;webpack:///src/*&quot;: &quot;${webRoot}/*&quot; } } ] } 설정 후에 npm run start을 헤준 후 debug해주고 싶은 부분에 점을 찍어 실행해준다. 유닛 테스트용 실행 스크립트 구성 VSCode에디터의 디버그 패널을 연 후, 실행 스크립트 구성을 추가해준다. 다음 코드를 configurations 배열 안에 넣어준다.1234567891011121314151617181920{ &quot;name&quot;: &quot;Debug CRA Tests&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;runtimeExecutable&quot;: &quot;${workspaceRoot}/node_modules/.bin/react-scripts&quot;, &quot;args&quot;: [ &quot;tests&quot;, &quot;--runInBand&quot;, &quot;--no-cache&quot;, &quot;--watchAll=false&quot; ], &quot;cwd&quot;: &quot;${workspaceRoot}&quot;, &quot;protocol&quot;: &quot;inspector&quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;env&quot;: { &quot;CI&quot;: &quot;true&quot; }, &quot;disableOptimisticBPs&quot;: true} 파일명.test.js 파일을 생성해준다. 이때 test 파일 안에는 index.js와 비슷하다. 1234567891011121314151617181920212223242526272829import React from 'react';import ReactDOM from 'react-dom';import Lecturers from './Lecturers'; // 검수할 파일import { FEML_lectures as lectures } from 'App'; // 필요한 데이터// 가상DOM을 실제DOM으로 패치헤서 확인하기 위해 변수 생성 let tester;// test 전에 div 생성후 tester에 참조 시켜준다.beforeEach(() =&gt; { tester = document.createElement('div');})// test 완료 후에 tester 삭제afterEach(() =&gt; { ReactDOM.unmountComponentAtNode(tester);})// 전달된 props를 받아 lecturers를 render를 해준다.const render = (props) =&gt; { ReactDOM.render(&lt;Lecturers instructor={props.lecturers} /&gt;, tester)}it('Front-End Masters League 강사진 중 첫번째 강사의 이름', () =&gt; { render({ lecturers }); const firstLecturerLink = tester.querySelector('.lecturer a'); const href = firstLecturerLink.getAttribute('href); expect(href).toEqual('https//facebook.com'); })","link":"/react/reactTip/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"리엑트 공부 순서","slug":"리엑트-공부-순서","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C/"},{"name":"React Props","slug":"React-Props","link":"/tags/React-Props/"},{"name":"React State","slug":"React-State","link":"/tags/React-State/"},{"name":"리엑트 컨텍스트","slug":"리엑트-컨텍스트","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"name":"리엑트 이벤트 핸들러","slug":"리엑트-이벤트-핸들러","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC/"},{"name":"리액트 컴포넌트 통신","slug":"리액트-컴포넌트-통신","link":"/tags/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%86%B5%EC%8B%A0/"},{"name":"리엑트 JSX","slug":"리엑트-JSX","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-JSX/"},{"name":"React 기본","slug":"React-기본","link":"/tags/React-%EA%B8%B0%EB%B3%B8/"},{"name":"리엑트 고차 컴포넌트(HOC)","slug":"리엑트-고차-컴포넌트-HOC","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-HOC/"},{"name":"리엑트 폼","slug":"리엑트-폼","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%8F%BC/"},{"name":"리엑트 훅","slug":"리엑트-훅","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%9B%85/"},{"name":"접근성","slug":"접근성","link":"/tags/%EC%A0%91%EA%B7%BC%EC%84%B1/"},{"name":"리엑트 팁","slug":"리엑트-팁","link":"/tags/%EB%A6%AC%EC%97%91%ED%8A%B8-%ED%8C%81/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"}]}